<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ™ºèƒ½è¯å“æ•°æ®ç®¡ç†ç³»ç»Ÿ</title>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Microsoft YaHei", "Segoe UI", Arial, sans-serif;
            background: #f5f5f5;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            font-size: 15.73px;
        }

        /* é¡¶éƒ¨å·¥å…·æ  */
        .ribbon {
            background: #fff;
            border-bottom: 1px solid #d4d4d4;
            padding: 8.8px 13.2px;
            display: flex;
            gap: 13.2px;
            align-items: center;
            box-shadow: 0 2.2px 4.4px rgba(0,0,0,0.05);
            z-index: 100;
        }

        .ribbon-group {
            display: flex;
            gap: 6.6px;
            padding-right: 13.2px;
            border-right: 1px solid #e0e0e0;
            align-items: center;
        }

        .ribbon-group:last-child {
            border-right: none;
        }

        .btn {
            padding: 6.6px 15.4px;
            border: 1px solid #d4d4d4;
            background: #fff;
            border-radius: 4.4px;
            cursor: pointer;
            font-size: 15.73px;
            display: flex;
            align-items: center;
            gap: 6.6px;
            transition: all 0.2s;
            color: #333;
        }

        .btn:hover {
            background: #f0f0f0;
            border-color: #b4b4b4;
        }

        .btn-primary {
            background: #217346;
            color: white;
            border-color: #217346;
        }

        .btn-primary:hover {
            background: #1e623d;
        }

        .btn-warning {
            background: #ff6b6b;
            color: white;
            border-color: #ff5252;
        }

        .btn-warning:hover {
            background: #ff5252;
        }

        .btn-active {
            background: #84cc16 !important;
            color: white !important;
            border-color: #65a30d !important;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #searchInput {
            width: 330px;
            padding: 6.6px 13.2px;
            border: 1px solid #d4d4d4;
            border-radius: 4.4px;
            font-size: 15.73px;
        }

        #searchInput:focus {
            outline: none;
            border-color: #217346;
            box-shadow: 0 0 0 3.3px rgba(33, 115, 70, 0.1);
        }

        /* è¡¨æ ¼å®¹å™¨ */
        .spreadsheet-container {
            flex: 1;
            overflow: auto;
            position: relative;
            background: #fff;
            transform-origin: top left;
        }

        /* Excelé£æ ¼è¡¨æ ¼ */
        .sheet-table {
            border-collapse: separate;
            border-spacing: 0;
            table-layout: fixed;
            user-select: none;
            font-size: 15.73px;
        }

        .sheet-table th,
        .sheet-table td {
            border: 1px solid #d4d4d4;
            padding: 0;
            position: relative;
            overflow: hidden;
        }

        /* è¡Œåˆ—å·æ ·å¼ */
        .sheet-table th {
            background: #f8f9fa;
            color: #666;
            font-weight: 600;
            text-align: center;
            position: sticky;
            z-index: 10;
            font-size: 16px;
        }

        .sheet-table th.corner {
            background: #f0f0f0;
            z-index: 20;
            top: 0;
            left: 0;
            width: 40px;
            min-width: 40px;
        }

        .sheet-table th.col-header {
            top: 0;
            min-width: 88px;
            height: 26.4px;
            line-height: 26.4px;
            font-size: 16px;
            border-bottom: 2px solid #c0c0c0;
            background: #e5f5d7;
            color: #3f6212;
        }

        /* åºå·åˆ— */
        .sheet-table th.row-header {
            left: 0;
            width: 40px;
            min-width: 40px;
            height: 26.4px;
            line-height: 26.4px;
            font-size: 16px;
            border-right: 2px solid #c0c0c0;
            cursor: pointer;
            background: #f0f9e8;
            color: #4d7c0f;
            text-align: left;
            padding-left: 4px;
        }

        .sheet-table th.row-header:hover {
            background: #dcfce7;
        }

        /* å•å…ƒæ ¼æ ·å¼ */
        .sheet-table td {
            width: 88px;
            min-width: 88px;
            height: 26.4px;
            background: #fff;
            cursor: cell;
        }

        .cell-content {
            width: 100%;
            height: 100%;
            padding: 2.2px 4.4px;
            font-size: 15.73px;
            line-height: 22px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            outline: none;
            border: 2px solid transparent;
            position: relative;
        }

        .cell-content.selected {
            border: 2px solid #217346;
            background: #e8f5e9;
        }

        .cell-content.editing {
            background: #fff;
            border: 2px solid #217346;
            z-index: 100;
            position: relative;
            cursor: text;
            user-select: text;
            white-space: pre;
            overflow: auto;
        }

        /* ç‰¹æ®Šåˆ—æ ·å¼ - Cã€Eå®½åº¦60pxï¼ŒDã€Få®½åº¦44px */
        td[data-col="D"], th[data-col="D"],
        td[data-col="F"], th[data-col="F"] {
            width: 44px !important;
            min-width: 44px !important;
            max-width: 44px !important;
        }

        td[data-col="C"], th[data-col="C"],
        td[data-col="E"], th[data-col="E"] {
            width: 60px !important;
            min-width: 60px !important;
            max-width: 60px !important;
        }

        /* éšè—å›ºå®šåˆ—çš„è°ƒæ•´æ‰‹æŸ„ */
        th[data-col="D"] .col-resize-handle,
        th[data-col="C"] .col-resize-handle,
        th[data-col="E"] .col-resize-handle,
        th[data-col="F"] .col-resize-handle {
            display: none !important;
        }

        td[data-col="D"] {
            background: #fcfcec !important;
            cursor: not-allowed !important;
        }

        td.meta-col {
            background: #f9f9f9 !important;
            font-size: 12.1px !important;
            color: #666 !important;
            width: 66px !important;
            min-width: 66px !important;
        }

        th.meta-col {
            background: #e0e0e0 !important;
            color: #666 !important;
            font-size: 13.2px !important;
            width: 66px !important;
            min-width: 66px !important;
        }

        /* å¯ç¼–è¾‘æ ‡é¢˜ */
        th.col-header.editable-header {
            cursor: text;
            background: #f0f9e8;
        }

        th.col-header.editable-header:hover {
            background: #dcfce7;
        }

        th.col-header .header-text {
            pointer-events: none;
        }

        th.col-header.editable-header .header-text {
            pointer-events: auto;
        }

        /* Iåˆ—é“¾æ¥æ ·å¼ */
        th[data-col="I"] {
            color: #1976d2 !important;
            text-decoration: underline !important;
            cursor: pointer !important;
        }

        th[data-col="I"]:hover {
            background: #e3f2fd !important;
        }

        /* æ ‡è®°é¢œè‰² */
        .cell-yellow { background-color: #fff200 !important; }
        .cell-red { background-color: #ef5350 !important; color: white !important; }
        .cell-pink { background-color: #f8bbd9 !important; }
        .duplicate-cell { background-color: #ef5350 !important; color: white !important; }
        .search-highlight { background-color: #fef08a !important; }

        /* è¡Œé«˜äº®æ•ˆæœ - æ·¡è“è‰²èƒŒæ™¯ */
        tr.row-highlight td {
            background-color: #e3f2fd !important;
        }

        /* æœ‰é¢œè‰²çš„å•å…ƒæ ¼è·³è¿‡é«˜äº® */
        tr.row-highlight td.cell-yellow,
        tr.row-highlight td.cell-red,
        tr.row-highlight td.cell-pink,
        tr.row-highlight td.duplicate-cell,
        tr.row-highlight td.search-highlight {
            background-color: inherit !important;
        }

        /* åºå·åˆ—é«˜äº® */
        th.row-header.row-highlight {
            background-color: #e3f2fd !important;
        }

        /* å¤‡æ³¨æŒ‡ç¤ºå™¨ - æ”¾å¤§ */
        .comment-indicator {
            position: absolute;
            top: 1px;
            right: 1px;
            width: 10px;
            height: 10px;
            background-color: #ef5350;
            border-radius: 50%;
            z-index: 1;
            pointer-events: none;
        }

        /* åˆ—å®½è°ƒæ•´æ‰‹æŸ„ */
        .col-resize-handle {
            position: absolute;
            top: 2.2px;
            right: 2.2px;
            width: 13.2px;
            height: 13.2px;
            border-radius: 3.3px;
            background-color: #a3e635;
            cursor: col-resize;
            z-index: 5;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .col-resize-handle:hover {
            opacity: 1;
            background-color: #84cc16;
        }

        /* å³é”®èœå• */
        .context-menu {
            position: absolute;
            width: 242px;
            background: white;
            border: 1px solid #d4d4d4;
            box-shadow: 0 4.4px 13.2px rgba(0,0,0,0.15);
            border-radius: 4.4px;
            padding: 4.4px 0;
            z-index: 10000;
            display: none;
        }

        .context-menu-item {
            padding: 8.8px 17.6px;
            cursor: pointer;
            font-size: 15.73px;
            display: flex;
            align-items: center;
            gap: 8.8px;
        }

        .context-menu-item:hover {
            background-color: #f0f0f0;
        }

        /* æ ‡ç²‰èœå•é¡¹ç‰¹æ®Šæ ·å¼ */
        .context-menu-item.pink-item::before {
            content: '';
            display: inline-block;
            width: 16px;
            height: 16px;
            background-color: #f8bbd9;
            border-radius: 3px;
            margin-right: 4px;
        }

        .context-menu-separator {
            height: 1px;
            background-color: #e0e0e0;
            margin: 4.4px 0;
        }

        /* å¤‡æ³¨å¼¹çª— */
        .comment-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #ffffe1;
            border: 2px solid #999;
            border-radius: 8.8px;
            padding: 22px;
            font-size: 16.94px;
            min-width: 330px;
            max-width: 550px;
            box-shadow: 0 8.8px 26.4px rgba(0,0,0,0.3);
            z-index: 10001;
            display: none;
            word-wrap: break-word;
            line-height: 1.6;
            color: #333;
        }

        .comment-popup.show {
            display: block;
            animation: popIn 0.3s;
        }

        @keyframes popIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        .comment-popup-close {
            position: absolute;
            top: 8.8px;
            right: 13.2px;
            cursor: pointer;
            font-size: 22px;
            color: #666;
        }

        .comment-popup-close:hover {
            color: #000;
        }

        /* æ‚¬åœå¤‡æ³¨æç¤º */
        .comment-tooltip {
            position: fixed;
            background: rgba(51, 51, 51, 0.95);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            max-width: 300px;
            word-wrap: break-word;
            z-index: 10002;
            display: none;
            pointer-events: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .comment-tooltip.show {
            display: block;
        }

        /* æ‹–æ‹½é€‰æ‹©æ¡† */
        .selection-box {
            position: absolute;
            background-color: rgba(56, 189, 248, 0.1);
            border: 2px solid #38bdf8;
            pointer-events: none;
            z-index: 100;
            display: none;
        }

        /* åŠ è½½é®ç½© */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255,255,255,0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            flex-direction: column;
            gap: 22px;
        }

        .loading-spinner {
            width: 55px;
            height: 55px;
            border: 5.5px solid #f3f3f3;
            border-top: 5.5px solid #217346;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .progress-bar {
            width: 330px;
            height: 22px;
            background: #e0e0e0;
            border-radius: 11px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #217346;
            width: 0%;
            transition: width 0.3s;
        }

        /* Toastæç¤º */
        .toast {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(51, 51, 51, 0.95);
            color: white;
            padding: 17.6px 35.2px;
            border-radius: 8.8px;
            font-size: 16.94px;
            z-index: 10001;
            display: none;
            box-shadow: 0 4.4px 13.2px rgba(0,0,0,0.3);
        }

        .toast.show {
            display: block;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        /* é®ç½©å±‚ */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 10000;
            display: none;
        }

        .modal-overlay.show {
            display: block;
        }

        /* æ»šåŠ¨æ¡ */
        ::-webkit-scrollbar {
            width: 13.2px;
            height: 13.2px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        ::-webkit-scrollbar-thumb {
            background-color: #c1c1c1;
            border-radius: 6.6px;
            border: 3.3px solid #f1f1f1;
        }

        ::-webkit-scrollbar-thumb:hover {
            background-color: #a1a1a1;
        }

        .hidden { display: none !important; }
    </style>
</head>
<body>

    <!-- åŠ è½½é®ç½© -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
        <div id="loadingText">æ­£åœ¨å¤„ç†...</div>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
    </div>

    <!-- Toastæç¤º -->
    <div class="toast" id="toast"></div>

    <!-- æ‚¬åœå¤‡æ³¨æç¤º -->
    <div class="comment-tooltip" id="commentTooltip"></div>

    <!-- é®ç½©å±‚ -->
    <div class="modal-overlay" id="modalOverlay"></div>

    <!-- å·¥å…·æ  -->
    <div class="ribbon">
        <div class="ribbon-group">
            <input type="text" id="searchInput" placeholder="æœç´¢æ¡ç æˆ–è¯å“åç§°(A/Båˆ—)...">
            <button class="btn" id="clearSearchBtn">æ¸…ç©º</button>
            <button class="btn" id="filterToggle">ç­›é€‰ï¼0</button>
        </div>

        <div class="ribbon-group">
            <label class="btn btn-primary">
                <span>ğŸ“‚ æ‰“å¼€</span>
                <input type="file" id="fileInput" accept=".xlsx,.xlsm" style="display: none;">
            </label>
            <button class="btn btn-warning" id="saveBtn">ğŸ’¾ ä¿å­˜</button>
        </div>

        <div class="ribbon-group">
            <button class="btn" id="addRowBtn">â• æ–°å¢è¡Œ</button>
            <button class="btn" id="undoBtn" disabled>â†©ï¸ æ’¤é”€</button>
            <button class="btn" id="redoBtn" disabled>â†ªï¸ æ¢å¤</button>
        </div>

        <div style="flex: 1;"></div>
    </div>

    <!-- è¡¨æ ¼åŒºåŸŸ -->
    <div class="spreadsheet-container" id="container">
        <table class="sheet-table" id="sheetTable">
            <thead id="tableHead"></thead>
            <tbody id="tableBody"></tbody>
        </table>
        <div class="selection-box" id="selectionBox"></div>
    </div>

    <!-- å³é”®èœå• -->
    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item" onclick="addComment()">ğŸ“ æ·»åŠ /ç¼–è¾‘å¤‡æ³¨</div>
        <div class="context-menu-item" onclick="clearComment()">ğŸ—‘ï¸ æ¸…é™¤å¤‡æ³¨</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" onclick="formatCell('red')">ğŸŸ¥ çº¢è‰²ï¼ˆæœ‰é—®é¢˜ï¼‰</div>
        <div class="context-menu-item" onclick="formatCell('yellow')">ğŸŸ¨ æ ‡é»„ï¼ˆè¡¥è¯ï¼‰</div>
        <div class="context-menu-item pink-item" onclick="formatCell('pink')">æ ‡ç²‰ï¼ˆå¦‡ç§‘ï¼‰</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" onclick="clearCellFormat()">â¬œ æ¸…é™¤é¢œè‰²</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" onclick="deleteSelectedRow()">ğŸ—‘ï¸ åˆ é™¤æ•´è¡Œ</div>
        <div class="context-menu-item" onclick="clearSelectedCells()">âŒ« æ¸…ç©ºå†…å®¹</div>
    </div>

    <!-- å¤‡æ³¨å¼¹çª— -->
    <div class="comment-popup" id="commentPopup">
        <span class="comment-popup-close" onclick="closeCommentPopup()">Ã—</span>
        <div id="commentPopupContent"></div>
    </div>

    <script>
        // ==================== é…ç½® ====================
        const CONFIG = {
            maxCol: 'AN',
            dataMaxCol: 'T',
            readOnlyCol: ['D'],
            calcHeaderCol: 'L',
            editableHeaders: ['H', 'I', 'J', 'K'], // Jå’ŒKä¹Ÿæ”¹ä¸ºå•å‡»ç¼–è¾‘
            formulaHeaders: ['J', 'K'],
            traceCodeCol: ['H','I','M','N'],
            countColForD: [],
            noMetaCols: ['C', 'D', 'E', 'F', 'G'],
            noResizeCols: ['C', 'D', 'E', 'F'],
            storageKey: 'medicine_excel_data_v2_3',
            metaDataSeparator: '|',
            batchSize: 50,
            maxHistory: 20,
            debounceDelay: 300,
            importChunkSize: 100
        };

        for(let i='H'.charCodeAt(0); i<='T'.charCodeAt(0); i++) {
            CONFIG.countColForD.push(String.fromCharCode(i));
        }

        // ==================== çŠ¶æ€ç®¡ç† ====================
        const state = {
            rows: 100,
            cols: 40,
            data: {},
            headerData: {},
            selectedCell: null,
            selectedCells: new Set(),
            editingCell: null,
            isFilterActive: false,
            searchTerm: '',
            filteredRows: new Set(),
            originalData: [],
            historyStack: [],
            redoStack: [],
            isUndoRedo: false,
            isProcessing: false,
            colLetters: [],
            dragStartCell: null,
            isDragging: false,
            lastClickTime: 0,
            lastRightClickTime: 0,
            activeInput: null,
            editingHeader: null,
            highlightedRow: null
        };

        function generateColLetters() {
            const letters = [];
            for (let i = 0; i < 26; i++) letters.push(String.fromCharCode(65 + i));
            for (let i = 0; i < 14; i++) letters.push('A' + String.fromCharCode(65 + i));
            return letters;
        }

        // ==================== åˆå§‹åŒ– ====================
        document.addEventListener('DOMContentLoaded', () => {
            state.colLetters = generateColLetters();
            initTable();
            initEvents();
            initSampleData();
            loadFromLocalStorage();
            saveToHistory();
        });

        // ==================== è¡¨æ ¼åˆå§‹åŒ– ====================
        function initTable() {
            const thead = document.getElementById('tableHead');
            const tbody = document.getElementById('tableBody');
            
            const headerText = {
                A: 'æ¡ç ', B: 'è¯å“åç§°', C: 'ä»·', D: 'æ— ç©º', E: 'hyj', F: 'ä¸Šé™', G: 'å¤‡æ³¨',
                H: 'Q02000000', I: 'ç‚¹å‡»è®¿é—®ç½‘ç«™', J: '240', K: '126.8', L: 'è®¡ç®—å€¼',
                M: '', N: '', O: '', P: '', Q: '', R: '', S: '', T: '',
                U: 'Aå…ƒ', V: 'Bå…ƒ', W: 'Cå…ƒ', X: 'Då…ƒ', Y: 'Eå…ƒ', Z: 'Få…ƒ',
                AA: 'Gå…ƒ', AB: 'Hå…ƒ', AC: 'Iå…ƒ', AD: 'Jå…ƒ', AE: 'Kå…ƒ', AF: 'Lå…ƒ',
                AG: 'Må…ƒ', AH: 'Nå…ƒ', AI: 'Oå…ƒ', AJ: 'På…ƒ', AK: 'Qå…ƒ', AL: 'Rå…ƒ',
                AM: 'Så…ƒ', AN: 'Tå…ƒ'
            };

            state.colLetters.forEach(col => {
                state.headerData[col] = headerText[col] || col;
            });

            let headerHTML = '<tr><th class="corner"></th>';
            state.colLetters.forEach((col, idx) => {
                const isMeta = idx >= 20;
                const isD = col === 'D';
                const isEditable = CONFIG.editableHeaders.includes(col);
                const isI = col === 'I';
                const text = state.headerData[col];
                const noResize = CONFIG.noResizeCols.includes(col);
                
                let width = getColWidth(col, idx);
                
                const classes = ['col-header'];
                if (isMeta) classes.push('meta-col');
                if (isEditable || isI) classes.push('editable-header');
                
                // Jå’ŒKåˆ—æ”¹ä¸ºå•å‡»ç¼–è¾‘
                const clickHandler = isI ? 'onclick="openWebsite()"' : 
                                   (isEditable ? 'onclick="editHeader(\'' + col + '\')"' : '');
                
                headerHTML += `<th class="${classes.join(' ')}" data-col="${col}" style="width: ${width}px; min-width: ${width}px; ${noResize ? 'max-width: ' + width + 'px;' : ''}" ${clickHandler}>
                    <span class="header-text">${text}</span>
                    ${(!isMeta && !noResize) ? '<div class="col-resize-handle" onmousedown="startColResize(event, \'' + col + '\')"></div>' : ''}
                </th>`;
            });
            headerHTML += '</tr>';
            thead.innerHTML = headerHTML;

            renderEmptyRows();
            calculateLHeader();
        }

        function getColWidth(col, idx) {
            if (col === 'A') return 135;
            if (col === 'C' || col === 'E') return 60; /* 60px */
            if (col === 'D' || col === 'F') return 44; /* ä¸Šé™å’Œæ— ç©ºä¸€æ ·å®½ */
            if (idx >= 7 && idx <= 19) return 161;
            if (idx >= 20) return 66;
            return 110;
        }

        function renderEmptyRows() {
            const tbody = document.getElementById('tableBody');
            let bodyHTML = '';
            for (let r = 0; r < state.rows; r++) {
                bodyHTML += `<tr data-row-num="${r + 1}"><th class="row-header" onclick="selectRow(${r})">${r + 1}</th>`;
                state.colLetters.forEach((col, idx) => {
                    const isMeta = idx >= 20;
                    const isReadOnly = CONFIG.readOnlyCol.includes(col);
                    const cellId = `${col}${r + 1}`;
                    const width = getColWidth(col, idx);
                    const noResize = CONFIG.noResizeCols.includes(col);
                    
                    bodyHTML += `
                        <td data-row="${r}" data-col="${col}" data-id="${cellId}" 
                            class="${isMeta ? 'meta-col' : ''} ${isReadOnly ? '' : 'editable'}"
                            style="width: ${width}px; min-width: ${width}px; ${noResize ? 'max-width: ' + width + 'px;' : ''}"
                            onclick="handleCellClick(event, '${cellId}')"
                            onmouseenter="highlightRow(${r}); showCommentTooltip(event, '${cellId}')"
                            onmouseleave="clearHighlight(); hideCommentTooltip()">
                            <div class="cell-content" id="cell-${cellId}"></div>
                        </td>
                    `;
                });
                bodyHTML += '</tr>';
            }
            tbody.innerHTML = bodyHTML;
        }

        // ==================== é«˜äº®è¡Œ ====================
        function highlightRow(rowIdx) {
            clearHighlight();
            state.highlightedRow = rowIdx;
            
            const row = document.querySelectorAll('#tableBody tr')[rowIdx];
            if (!row || row.classList.contains('hidden-row')) return;
            
            row.classList.add('row-highlight');
            
            const rowHeader = row.querySelector('.row-header');
            if (rowHeader) rowHeader.classList.add('row-highlight');
        }

        function clearHighlight() {
            document.querySelectorAll('.row-highlight').forEach(el => {
                el.classList.remove('row-highlight');
            });
            state.highlightedRow = null;
        }

        // ==================== æ ‡é¢˜ç¼–è¾‘ ====================
        function editHeader(col) {
            if (state.editingHeader) return;
            
            const th = document.querySelector(`th[data-col="${col}"]`);
            const currentText = state.headerData[col];
            
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentText;
            input.style.cssText = 'width: 100%; height: 100%; border: none; outline: 2px solid #217346; padding: 2px; font-size: 14px; font-weight: bold; text-align: center;';
            
            const span = th.querySelector('.header-text');
            span.style.display = 'none';
            th.appendChild(input);
            input.focus();
            input.select();
            
            state.editingHeader = col;
            
            const finishEdit = () => {
                const newValue = input.value.trim();
                if (newValue && newValue !== currentText) {
                    state.headerData[col] = newValue;
                    span.textContent = newValue;
                    
                    if (CONFIG.formulaHeaders.includes(col)) {
                        calculateLHeader();
                    }
                    
                    saveToHistory();
                }
                input.remove();
                span.style.display = '';
                state.editingHeader = null;
            };
            
            input.addEventListener('blur', finishEdit);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    finishEdit();
                } else if (e.key === 'Escape') {
                    input.remove();
                    span.style.display = '';
                    state.editingHeader = null;
                }
            });
        }

        function calculateLHeader() {
            const jVal = parseFloat(state.headerData['J']) || 0;
            const kVal = parseFloat(state.headerData['K']) || 0;
            const lVal = (jVal - kVal).toFixed(1);
            state.headerData['L'] = lVal;
            
            const thL = document.querySelector(`th[data-col="L"] .header-text`);
            if (thL) thL.textContent = lVal;
        }

        function openWebsite() {
            window.open('https://www.mashangfangxin.com/', '_blank', 'noopener,noreferrer');
        }

        // ==================== äº‹ä»¶å¤„ç† ====================
        function initEvents() {
            const searchInput = document.getElementById('searchInput');
            searchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    performSearch();
                    jumpToSearchResult();
                }
            });
            
            document.getElementById('clearSearchBtn').addEventListener('click', clearSearch);
            document.getElementById('filterToggle').addEventListener('click', toggleFilter);
            
            document.getElementById('fileInput').addEventListener('change', handleExcelImport);
            document.getElementById('saveBtn').addEventListener('click', saveToExcel);
            
            document.getElementById('addRowBtn').addEventListener('click', handleAddRowClick);
            document.getElementById('undoBtn').addEventListener('click', undo);
            document.getElementById('redoBtn').addEventListener('click', redo);
            
            document.addEventListener('keydown', handleGlobalKeydown);
            
            initDragSelection();
            
            // å…¨å±€å³é”®åŒå‡»æ£€æµ‹
            document.addEventListener('contextmenu', handleGlobalRightClick);
            
            // ä½¿ç”¨ mousedown ç¡®ä¿å³é”®èœå•åŠæ—¶å…³é—­
            document.addEventListener('mousedown', (e) => {
                const menu = document.getElementById('contextMenu');
                if (menu.style.display === 'block' && !e.target.closest('.context-menu')) {
                    menu.style.display = 'none';
                }
            });

            window.addEventListener('beforeunload', saveToLocalStorage);
        }

        // ==================== æ–°å¢è¡ŒæŒ‰é’®å¤„ç† ====================
        function handleAddRowClick() {
            const container = document.getElementById('container');
            const scrollHeight = container.scrollHeight;
            const clientHeight = container.clientHeight;
            const scrollTop = container.scrollTop;
            
            const isAtBottom = scrollTop + clientHeight >= scrollHeight - 10;
            
            if (!isAtBottom) {
                container.scrollTop = scrollHeight;
            } else {
                addNewRow();
            }
        }

        // ==================== æ‚¬åœå¤‡æ³¨æç¤º ====================
        function showCommentTooltip(e, cellId) {
            const cell = document.getElementById(`cell-${cellId}`);
            const comment = cell.dataset.comment;
            
            if (comment) {
                const tooltip = document.getElementById('commentTooltip');
                tooltip.textContent = comment;
                tooltip.style.left = (e.clientX + 10) + 'px';
                tooltip.style.top = (e.clientY + 10) + 'px';
                tooltip.classList.add('show');
            }
        }

        function hideCommentTooltip() {
            const tooltip = document.getElementById('commentTooltip');
            tooltip.classList.remove('show');
        }

        // ==================== å³é”®åŒå‡»å¤„ç† ====================
        function handleGlobalRightClick(e) {
            const cell = e.target.closest('td[data-col]');
            if (!cell) return;
            
            const currentTime = new Date().getTime();
            const timeDiff = currentTime - state.lastRightClickTime;
            
            if (timeDiff < 300) {
                e.preventDefault();
                e.stopPropagation();
                
                const cellId = cell.dataset.id;
                selectCell(cellId);
                showContextMenu(e, cellId);
                
                state.lastRightClickTime = 0;
            } else {
                state.lastRightClickTime = currentTime;
            }
        }

        // ==================== æœç´¢è·³è½¬ ====================
        function jumpToSearchResult() {
            if (!state.searchTerm || state.filteredRows.size === 0) return;
            
            const firstMatchRow = Math.min(...Array.from(state.filteredRows));
            
            for (let col of CONFIG.countColForD) {
                const cellId = `${col}${firstMatchRow}`;
                const value = state.data[cellId];
                if (value && value.trim() !== '') {
                    const cell = document.getElementById(`cell-${cellId}`);
                    if (cell && !cell.closest('tr').classList.contains('hidden-row')) {
                        selectCell(cellId);
                        cell.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        return;
                    }
                }
            }
            
            const hCellId = `H${firstMatchRow}`;
            const hCell = document.getElementById(`cell-${hCellId}`);
            if (hCell && !hCell.closest('tr').classList.contains('hidden-row')) {
                selectCell(hCellId);
                hCell.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        // ==================== å•å…ƒæ ¼æ“ä½œ ====================
        function handleCellClick(e, cellId) {
            e.stopPropagation();
            
            const cell = document.getElementById(`cell-${cellId}`);
            const td = cell.parentElement;
            
            if (e.ctrlKey) {
                toggleCellSelection(td);
            } else if (e.shiftKey && state.selectedCell) {
                selectCellRange(state.selectedCell, cellId);
            } else {
                selectCell(cellId);
                
                // å•å‡»ç›´æ¥ç¼–è¾‘ï¼Œå¹¶å®šä½å…‰æ ‡
                if (td.classList.contains('editable') && !td.classList.contains('meta-col')) {
                    startEdit(cellId, e);
                }
            }
        }

        function selectCell(cellId) {
            document.querySelectorAll('.cell-content.selected').forEach(el => {
                el.classList.remove('selected');
            });
            document.querySelectorAll('tr.row-selected').forEach(tr => {
                tr.classList.remove('row-selected');
            });
            state.selectedCells.clear();
            
            state.selectedCell = cellId;
            const cell = document.getElementById(`cell-${cellId}`);
            if (cell) {
                cell.classList.add('selected');
                cell.focus();
            }
        }

        function selectRow(rowIdx) {
            clearAllSelections();
            const row = document.querySelectorAll('#tableBody tr')[rowIdx];
            if (row.classList.contains('hidden-row')) return;
            
            row.classList.add('row-selected');
            
            const editableCells = row.querySelectorAll('td.editable');
            editableCells.forEach(cell => {
                state.selectedCells.add(cell.dataset.id);
                cell.querySelector('.cell-content').classList.add('selected');
            });
            
            if (editableCells.length > 0) {
                selectCell(editableCells[0].dataset.id);
            }
        }

        function toggleCellSelection(td) {
            const cellId = td.dataset.id;
            const cell = td.querySelector('.cell-content');
            
            if (state.selectedCells.has(cellId)) {
                state.selectedCells.delete(cellId);
                cell.classList.remove('selected');
            } else {
                state.selectedCells.add(cellId);
                cell.classList.add('selected');
                state.selectedCell = cellId;
            }
        }

        function selectCellRange(startId, endId) {
            clearAllSelections();
            selectCell(endId);
        }

        function clearAllSelections() {
            document.querySelectorAll('.cell-content.selected').forEach(el => {
                el.classList.remove('selected');
            });
            document.querySelectorAll('tr.row-selected').forEach(tr => {
                tr.classList.remove('row-selected');
            });
            state.selectedCells.clear();
        }

        // ==================== ç¼–è¾‘åŠŸèƒ½ ====================
        function startEdit(cellId, clickEvent) {
            if (state.editingCell) endEdit();
            
            if (state.isFilterActive || state.searchTerm) {
                const actualRow = getActualRowNumber(cellId);
                if (actualRow) {
                    cellId = cellId.replace(/\d+$/, actualRow);
                }
            }
            
            state.editingCell = cellId;
            const cell = document.getElementById(`cell-${cellId}`);
            
            // ä¿å­˜å½“å‰å†…å®¹ï¼ˆåŒ…æ‹¬çº¢ç‚¹ï¼‰
            const currentContent = cell.innerHTML;
            const hasIndicator = cell.querySelector('.comment-indicator');
            
            cell.contentEditable = true;
            cell.classList.add('editing');
            cell.focus();
            
            // æ¢å¤å†…å®¹ä»¥ç¡®ä¿çº¢ç‚¹ä¿ç•™
            if (hasIndicator) {
                cell.innerHTML = currentContent;
            }
            
            // ç²¾ç¡®å®šä½å…‰æ ‡
            if (clickEvent) {
                const range = document.caretRangeFromPoint(clickEvent.clientX, clickEvent.clientY);
                if (range) {
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                }
            }
            
            state.activeInput = cell;
        }

        function endEdit() {
            if (!state.editingCell) return;
            
            const cellId = state.editingCell;
            const cell = document.getElementById(`cell-${cellId}`);
            
            // è·å–æ–‡æœ¬å†…å®¹æ—¶æ’é™¤çº¢ç‚¹
            const indicator = cell.querySelector('.comment-indicator');
            if (indicator) indicator.remove();
            
            const value = cell.textContent;
            const oldValue = state.data[cellId] || '';
            
            // æ¢å¤çº¢ç‚¹
            if (cell.dataset.comment) {
                if (!cell.querySelector('.comment-indicator')) {
                    const newIndicator = document.createElement('div');
                    newIndicator.className = 'comment-indicator';
                    cell.appendChild(newIndicator);
                }
            }
            
            if (value !== oldValue) {
                setCellData(cellId, value);
                
                const col = cellId.match(/[A-Z]+/)[0];
                if (isDataCol(col) && !CONFIG.noMetaCols.includes(col)) {
                    syncMetaData(cellId);
                }
                
                calculateDColumn();
                checkDuplicates();
                saveToHistory();
            }
            
            cell.contentEditable = false;
            cell.classList.remove('editing');
            state.editingCell = null;
            state.activeInput = null;
        }

        function setCellData(cellId, value) {
            state.data[cellId] = value;
            const cell = document.getElementById(`cell-${cellId}`);
            if (cell) {
                // ä¿ç•™çº¢ç‚¹çš„æƒ…å†µä¸‹æ›´æ–°æ–‡æœ¬
                const indicator = cell.querySelector('.comment-indicator');
                cell.textContent = value;
                if (indicator) {
                    cell.appendChild(indicator);
                }
            }
        }

        function moveToNextCell() {
            if (!state.selectedCell) return;
            
            const match = state.selectedCell.match(/([A-Z]+)(\d+)/);
            const col = match[1];
            const row = parseInt(match[2]);
            
            const colIndex = state.colLetters.indexOf(col);
            let nextColIndex = colIndex + 1;
            
            while (nextColIndex < state.colLetters.length) {
                const nextCol = state.colLetters[nextColIndex];
                if (!CONFIG.readOnlyCol.includes(nextCol) && !isMetaCol(nextCol)) {
                    const nextCellId = `${nextCol}${row}`;
                    const nextCell = document.getElementById(`cell-${nextCellId}`);
                    if (nextCell && !nextCell.closest('tr').classList.contains('hidden-row')) {
                        selectCell(nextCellId);
                        startEdit(nextCellId);
                        return;
                    }
                }
                nextColIndex++;
            }
            
            const nextRow = row + 1;
            if (nextRow <= state.rows) {
                for (let i = 0; i < state.colLetters.length; i++) {
                    const c = state.colLetters[i];
                    if (!CONFIG.readOnlyCol.includes(c) && !isMetaCol(c)) {
                        const nextCellId = `${c}${nextRow}`;
                        const nextCell = document.getElementById(`cell-${nextCellId}`);
                        if (nextCell && !nextCell.closest('tr').classList.contains('hidden-row')) {
                            selectCell(nextCellId);
                            startEdit(nextCellId);
                            return;
                        }
                    }
                }
            }
        }

        // ==================== æ ¸å¿ƒåŠŸèƒ½ ====================
        function isDataCol(col) {
            return col >= 'A' && col <= 'T';
        }

        function isMetaCol(col) {
            const idx = state.colLetters.indexOf(col);
            return idx >= 20;
        }

        function getMetaCol(dataCol) {
            const index = dataCol.charCodeAt(0) - 'A'.charCodeAt(0);
            const metaIndex = index + 20;
            if (metaIndex < 26) {
                return String.fromCharCode(65 + metaIndex);
            } else {
                return 'A' + String.fromCharCode(65 + (metaIndex - 26));
            }
        }

        function getActualRowNumber(cellId) {
            const displayRow = parseInt(cellId.match(/\d+/)[0]);
            const visibleRows = Array.from(document.querySelectorAll('#tableBody tr:not(.hidden-row)'));
            if (visibleRows[displayRow - 1]) {
                return visibleRows[displayRow - 1].dataset.rowNum;
            }
            return null;
        }

        function syncMetaData(cellId) {
            const col = cellId.match(/[A-Z]+/)[0];
            if (!isDataCol(col) || CONFIG.noMetaCols.includes(col)) return;
            
            const row = cellId.match(/\d+/)[0];
            const metaCol = getMetaCol(col);
            const metaCellId = `${metaCol}${row}`;
            
            const cell = document.getElementById(`cell-${cellId}`);
            let color = '';
            if (cell.classList.contains('cell-yellow')) color = 'é»„è‰²';
            else if (cell.classList.contains('cell-red')) color = 'çº¢è‰²';
            else if (cell.classList.contains('cell-pink')) color = 'ç²‰è‰²';
            
            const comment = cell.dataset.comment || '';
            const metaValue = color + (comment ? CONFIG.metaDataSeparator + comment : '');
            
            setCellData(metaCellId, metaValue);
        }

        function calculateDColumn() {
            for (let r = 1; r <= state.rows; r++) {
                let count = 0;
                CONFIG.countColForD.forEach(col => {
                    const cellId = `${col}${r}`;
                    if (state.data[cellId] && state.data[cellId].trim() !== '') {
                        count++;
                    }
                });
                setCellData(`D${r}`, count.toString());
            }
        }

        function checkDuplicates() {
            const excludeCols = ['C','D','E','F','G'];
            const valueMap = new Map();
            
            for (let r = 1; r <= state.rows; r++) {
                state.colLetters.forEach(col => {
                    if (!isDataCol(col) || excludeCols.includes(col)) return;
                    
                    const cellId = `${col}${r}`;
                    const value = (state.data[cellId] || '').trim();
                    if (!value) return;
                    
                    const num = parseFloat(value);
                    if (!isNaN(num) && num >= 0 && num <= 10) return;
                    
                    if (!valueMap.has(value)) valueMap.set(value, []);
                    valueMap.get(value).push(cellId);
                });
            }
            
            document.querySelectorAll('.duplicate-cell').forEach(el => {
                el.classList.remove('duplicate-cell');
            });
            
            valueMap.forEach((cellIds, value) => {
                if (cellIds.length > 1) {
                    cellIds.forEach(id => {
                        const cell = document.getElementById(`cell-${id}`);
                        if (cell) cell.classList.add('duplicate-cell');
                    });
                }
            });
        }

        // ==================== æ ¼å¼åŒ– ====================
        function formatCell(color) {
            const targets = state.selectedCells.size > 0 ? 
                Array.from(state.selectedCells) : 
                (state.selectedCell ? [state.selectedCell] : []);
            
            targets.forEach(cellId => {
                const col = cellId.match(/[A-Z]+/)[0];
                if (CONFIG.noMetaCols.includes(col)) return;
                
                const cell = document.getElementById(`cell-${cellId}`);
                cell.classList.remove('cell-yellow', 'cell-red', 'cell-pink');
                if (color !== 'clear') {
                    cell.classList.add(`cell-${color}`);
                }
                
                if (isDataCol(col) && !CONFIG.noMetaCols.includes(col)) {
                    syncMetaData(cellId);
                }
            });
            
            saveToHistory();
        }

        function clearCellFormat() {
            formatCell('clear');
        }

        // ==================== å¤‡æ³¨åŠŸèƒ½ ====================
        function addComment() {
            const cellId = state.selectedCell;
            if (!cellId) return;
            
            const col = cellId.match(/[A-Z]+/)[0];
            if (CONFIG.noMetaCols.includes(col)) {
                showToast('C-Gåˆ—ä¸æ”¯æŒå¤‡æ³¨åŠŸèƒ½');
                return;
            }
            
            const cell = document.getElementById(`cell-${cellId}`);
            const currentComment = cell.dataset.comment || '';
            
            const newComment = prompt('è¯·è¾“å…¥å¤‡æ³¨ï¼š', currentComment);
            if (newComment === null) return;
            
            if (newComment.trim()) {
                cell.dataset.comment = newComment.trim();
                if (!cell.querySelector('.comment-indicator')) {
                    const indicator = document.createElement('div');
                    indicator.className = 'comment-indicator';
                    cell.appendChild(indicator);
                }
            } else {
                clearComment();
                return;
            }
            
            syncMetaData(cellId);
            saveToHistory();
        }

        function clearComment() {
            const cellId = state.selectedCell;
            if (!cellId) return;
            
            const col = cellId.match(/[A-Z]+/)[0];
            if (CONFIG.noMetaCols.includes(col)) return;
            
            const cell = document.getElementById(`cell-${cellId}`);
            delete cell.dataset.comment;
            const indicator = cell.querySelector('.comment-indicator');
            if (indicator) indicator.remove();
            
            syncMetaData(cellId);
            saveToHistory();
        }

        function showContextMenu(e, cellId) {
            e.preventDefault();
            selectCell(cellId);
            
            const menu = document.getElementById('contextMenu');
            let menuX = e.pageX;
            let menuY = e.pageY;
            
            const menuWidth = 242;
            const menuHeight = 350;
            
            if (menuX + menuWidth > window.innerWidth) {
                menuX = window.innerWidth - menuWidth - 10;
            }
            if (menuY + menuHeight > window.innerHeight) {
                menuY = window.innerHeight - menuHeight - 10;
            }
            if (menuY < 0) menuY = 10;
            
            menu.style.display = 'block';
            menu.style.left = menuX + 'px';
            menu.style.top = menuY + 'px';
        }

        // ==================== æœç´¢ç­›é€‰ ====================
        function performSearch() {
            const term = document.getElementById('searchInput').value.trim().toLowerCase();
            state.searchTerm = term;
            
            if (!term) {
                clearSearch();
                return;
            }
            
            document.querySelectorAll('.search-highlight').forEach(el => {
                el.classList.remove('search-highlight');
            });
            document.querySelectorAll('#tableBody tr').forEach(tr => {
                tr.classList.remove('hidden-row');
            });
            
            state.filteredRows.clear();
            
            for (let r = 1; r <= state.rows; r++) {
                const aVal = (state.data[`A${r}`] || '').toLowerCase();
                const bVal = (state.data[`B${r}`] || '').toLowerCase();
                
                const row = document.querySelector(`tr[data-row-num="${r}"]`);
                
                if (aVal.includes(term) || bVal.includes(term)) {
                    state.filteredRows.add(r);
                    if (aVal.includes(term)) {
                        document.getElementById(`cell-A${r}`).classList.add('search-highlight');
                    }
                    if (bVal.includes(term)) {
                        document.getElementById(`cell-B${r}`).classList.add('search-highlight');
                    }
                } else {
                    row.classList.add('hidden-row');
                }
            }
            
            showToast(`æ‰¾åˆ° ${state.filteredRows.size} ä¸ªåŒ¹é…é¡¹`);
        }

        function clearSearch() {
            document.getElementById('searchInput').value = '';
            state.searchTerm = '';
            state.filteredRows.clear();
            
            document.querySelectorAll('.search-highlight').forEach(el => {
                el.classList.remove('search-highlight');
            });
            document.querySelectorAll('#tableBody tr').forEach(tr => {
                tr.classList.remove('hidden-row');
            });
            
            if (state.isFilterActive) {
                applyFilter();
            }
        }

        function toggleFilter() {
            state.isFilterActive = !state.isFilterActive;
            const btn = document.getElementById('filterToggle');
            btn.classList.toggle('btn-active', state.isFilterActive);
            
            if (state.isFilterActive) {
                applyFilter();
            } else {
                clearFilter();
            }
            
            saveToHistory();
        }

        function applyFilter() {
            document.querySelectorAll('#tableBody tr').forEach(tr => {
                tr.classList.remove('hidden-row');
            });
            
            let visibleCount = 0;
            
            for (let r = 1; r <= state.rows; r++) {
                const dVal = parseInt(state.data[`D${r}`] || '0');
                const row = document.querySelector(`tr[data-row-num="${r}"]`);
                
                if (dVal <= 0) {
                    row.classList.add('hidden-row');
                } else {
                    visibleCount++;
                }
            }
            
            showToast(`ç­›é€‰æ˜¾ç¤º ${visibleCount} è¡Œ`);
        }

        function clearFilter() {
            document.querySelectorAll('#tableBody tr').forEach(tr => {
                tr.classList.remove('hidden-row');
            });
        }

        // ==================== è¡Œåˆ—æ“ä½œ ====================
        function addNewRow() {
            state.rows++;
            const tbody = document.getElementById('tableBody');
            const r = state.rows - 1;
            
            let html = `<tr data-row-num="${state.rows}"><th class="row-header" onclick="selectRow(${r})">${state.rows}</th>`;
            state.colLetters.forEach((col, idx) => {
                const isMeta = idx >= 20;
                const isReadOnly = CONFIG.readOnlyCol.includes(col);
                const cellId = `${col}${state.rows}`;
                const width = getColWidth(col, idx);
                const noResize = CONFIG.noResizeCols.includes(col);
                
                html += `
                    <td data-row="${r}" data-col="${col}" data-id="${cellId}" 
                        class="${isMeta ? 'meta-col' : ''} ${isReadOnly ? '' : 'editable'}"
                        style="width: ${width}px; min-width: ${width}px; ${noResize ? 'max-width: ' + width + 'px;' : ''}"
                        onclick="handleCellClick(event, '${cellId}')"
                        onmouseenter="highlightRow(${r}); showCommentTooltip(event, '${cellId}')"
                        onmouseleave="clearHighlight(); hideCommentTooltip()">
                        <div class="cell-content" id="cell-${cellId}"></div>
                    </td>
                `;
            });
            html += '</tr>';
            
            tbody.insertAdjacentHTML('beforeend', html);
            setCellData(`D${state.rows}`, '0');
            
            const container = document.getElementById('container');
            container.scrollTop = container.scrollHeight;
            
            saveToHistory();
        }

        function deleteSelectedRow() {
            if (!state.selectedCell) return;
            
            const rowNum = parseInt(state.selectedCell.match(/\d+/)[0]);
            
            state.colLetters.forEach(col => {
                const cellId = `${col}${rowNum}`;
                delete state.data[cellId];
            });
            
            for (let r = rowNum; r < state.rows; r++) {
                state.colLetters.forEach(col => {
                    const fromId = `${col}${r + 1}`;
                    const toId = `${col}${r}`;
                    state.data[toId] = state.data[fromId];
                    delete state.data[fromId];
                });
            }
            
            state.rows--;
            
            renderEmptyRows();
            
            Object.entries(state.data).forEach(([cellId, value]) => {
                const cell = document.getElementById(`cell-${cellId}`);
                if (cell) cell.textContent = value;
            });
            
            restoreStyles();
            
            calculateDColumn();
            checkDuplicates();
            clearAllSelections();
            saveToHistory();
        }

        function restoreStyles() {
            for (let r = 1; r <= state.rows; r++) {
                for (let c = 'A'; c <= 'T'; c = String.fromCharCode(c.charCodeAt(0) + 1)) {
                    if (CONFIG.noMetaCols.includes(c)) continue;
                    
                    const metaCol = getMetaCol(c);
                    const metaCellId = `${metaCol}${r}`;
                    const metaValue = state.data[metaCellId] || '';
                    
                    if (metaValue) {
                        const parts = metaValue.split(CONFIG.metaDataSeparator);
                        const color = parts[0];
                        const comment = parts[1];
                        
                        const cellId = `${c}${r}`;
                        const cell = document.getElementById(`cell-${cellId}`);
                        
                        if (color === 'é»„è‰²') cell.classList.add('cell-yellow');
                        else if (color === 'çº¢è‰²') cell.classList.add('cell-red');
                        else if (color === 'ç²‰è‰²') cell.classList.add('cell-pink');
                        
                        if (comment) {
                            cell.dataset.comment = comment;
                            if (!cell.querySelector('.comment-indicator')) {
                                const indicator = document.createElement('div');
                                indicator.className = 'comment-indicator';
                                cell.appendChild(indicator);
                            }
                        }
                    }
                }
            }
        }

        function clearSelectedCells() {
            const targets = state.selectedCells.size > 0 ? 
                Array.from(state.selectedCells) : 
                (state.selectedCell ? [state.selectedCell] : []);
            
            targets.forEach(cellId => {
                const col = cellId.match(/[A-Z]+/)[0];
                if (CONFIG.readOnlyCol.includes(col)) {
                    setCellData(cellId, '0');
                } else {
                    setCellData(cellId, '');
                }
            });
            
            calculateDColumn();
            saveToHistory();
        }

        // ==================== åˆ—å®½è°ƒæ•´ ====================
        function startColResize(e, col) {
            if (CONFIG.noResizeCols.includes(col)) return;
            
            e.stopPropagation();
            
            let isResizing = true;
            const th = document.querySelector(`th[data-col="${col}"]`);
            const startX = e.clientX;
            const startWidth = th.offsetWidth;
            
            function onMouseMove(e) {
                if (!isResizing) return;
                const newWidth = Math.max(20, startWidth + (e.clientX - startX));
                
                th.style.width = newWidth + 'px';
                th.style.minWidth = newWidth + 'px';
                
                document.querySelectorAll(`td[data-col="${col}"]`).forEach(td => {
                    td.style.width = newWidth + 'px';
                    td.style.minWidth = newWidth + 'px';
                });
            }
            
            function onMouseUp() {
                isResizing = false;
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                saveToHistory();
            }
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }

        // ==================== å†å²è®°å½• ====================
        function saveToHistory() {
            if (state.isUndoRedo) return;
            
            state.redoStack = [];
            if (state.historyStack.length >= CONFIG.maxHistory) {
                state.historyStack.shift();
            }
            
            state.historyStack.push({
                data: JSON.parse(JSON.stringify(state.data)),
                headerData: JSON.parse(JSON.stringify(state.headerData)),
                rows: state.rows
            });
            
            updateUndoRedoButtons();
        }

        function undo() {
            if (state.historyStack.length <= 1) return;
            
            state.isUndoRedo = true;
            state.redoStack.push(state.historyStack.pop());
            restoreState(state.historyStack[state.historyStack.length - 1]);
            state.isUndoRedo = false;
            
            updateUndoRedoButtons();
        }

        function redo() {
            if (state.redoStack.length === 0) return;
            
            state.isUndoRedo = true;
            const nextState = state.redoStack.pop();
            state.historyStack.push(nextState);
            restoreState(nextState);
            state.isUndoRedo = false;
            
            updateUndoRedoButtons();
        }

        function restoreState(savedState) {
            state.data = JSON.parse(JSON.stringify(savedState.data));
            state.headerData = JSON.parse(JSON.stringify(savedState.headerData));
            state.rows = savedState.rows;
            
            Object.entries(state.headerData).forEach(([col, value]) => {
                const th = document.querySelector(`th[data-col="${col}"] .header-text`);
                if (th) th.textContent = value;
            });
            
            renderEmptyRows();
            
            Object.entries(state.data).forEach(([cellId, value]) => {
                const cell = document.getElementById(`cell-${cellId}`);
                if (cell) cell.textContent = value;
            });
            
            restoreStyles();
            calculateDColumn();
            checkDuplicates();
        }

        function updateUndoRedoButtons() {
            document.getElementById('undoBtn').disabled = state.historyStack.length <= 1;
            document.getElementById('redoBtn').disabled = state.redoStack.length === 0;
        }

        // ==================== Excelå¯¼å…¥å¯¼å‡º ====================
        async function handleExcelImport(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            showLoading('æ­£åœ¨å¯¼å…¥...');
            
            try {
                const data = await file.arrayBuffer();
                const workbook = XLSX.read(data, { type: 'array' });
                const sheet = workbook.Sheets[workbook.SheetNames[0]];
                const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
                
                if (jsonData.length > 0) {
                    const headers = jsonData[0];
                    headers.forEach((h, idx) => {
                        if (idx < state.colLetters.length && h) {
                            state.headerData[state.colLetters[idx]] = String(h);
                        }
                    });
                }
                
                const rows = jsonData.slice(1);
                state.rows = Math.max(rows.length, 100);
                renderEmptyRows();
                
                Object.entries(state.headerData).forEach(([col, value]) => {
                    const th = document.querySelector(`th[data-col="${col}"] .header-text`);
                    if (th) th.textContent = value;
                });
                
                rows.forEach((row, rIdx) => {
                    row.forEach((val, cIdx) => {
                        if (val !== undefined && val !== null && cIdx < state.colLetters.length) {
                            const col = state.colLetters[cIdx];
                            setCellData(`${col}${rIdx + 1}`, String(val));
                        }
                    });
                });
                
                calculateLHeader();
                calculateDColumn();
                checkDuplicates();
                restoreStyles();
                saveToHistory();
                
                hideLoading();
                showToast(`æˆåŠŸå¯¼å…¥ ${rows.length} è¡Œæ•°æ®`);
            } catch (err) {
                hideLoading();
                showToast('å¯¼å…¥å¤±è´¥: ' + err.message);
            }
            
            e.target.value = '';
        }

        function saveToExcel() {
            showLoading('æ­£åœ¨å¯¼å‡º...');
            
            try {
                const data = [];
                
                const header = state.colLetters.map(col => state.headerData[col] || col);
                data.push(header);
                
                for (let r = 1; r <= state.rows; r++) {
                    const row = [];
                    let hasData = false;
                    state.colLetters.forEach(col => {
                        const val = state.data[`${col}${r}`] || '';
                        row.push(val);
                        if (val) hasData = true;
                    });
                    if (hasData) data.push(row);
                }
                
                const ws = XLSX.utils.aoa_to_sheet(data);
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, 'è¯å“æ•°æ®');
                
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const filename = `ybæ•°æ®${year}${month}${day} ${hours}${minutes}.xlsx`;
                
                XLSX.writeFile(wb, filename);
                
                hideLoading();
                showToast('å¯¼å‡ºæˆåŠŸ');
            } catch (err) {
                hideLoading();
                showToast('å¯¼å‡ºå¤±è´¥: ' + err.message);
            }
        }

        // ==================== æœ¬åœ°å­˜å‚¨ ====================
        function saveToLocalStorage() {
            try {
                const data = {
                    data: state.data,
                    headerData: state.headerData,
                    rows: state.rows,
                    version: '2.3'
                };
                localStorage.setItem(CONFIG.storageKey, JSON.stringify(data));
            } catch (e) {
                console.error('ä¿å­˜å¤±è´¥:', e);
            }
        }

        function loadFromLocalStorage() {
            try {
                const saved = localStorage.getItem(CONFIG.storageKey);
                if (!saved) return false;
                
                const parsed = JSON.parse(saved);
                state.data = parsed.data || {};
                state.headerData = parsed.headerData || {};
                state.rows = parsed.rows || 100;
                
                renderEmptyRows();
                
                Object.entries(state.headerData).forEach(([col, value]) => {
                    const th = document.querySelector(`th[data-col="${col}"] .header-text`);
                    if (th) th.textContent = value;
                });
                
                Object.entries(state.data).forEach(([cellId, value]) => {
                    const cell = document.getElementById(`cell-${cellId}`);
                    if (cell) cell.textContent = value;
                });
                
                calculateLHeader();
                calculateDColumn();
                checkDuplicates();
                restoreStyles();
                return true;
            } catch (e) {
                console.error('åŠ è½½å¤±è´¥:', e);
                return false;
            }
        }

        // ==================== è¾…åŠ©å‡½æ•° ====================
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function showLoading(text) {
            document.getElementById('loadingText').textContent = text;
            document.getElementById('loadingOverlay').style.display = 'flex';
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').style.display = 'none';
        }

        function showToast(msg) {
            const toast = document.getElementById('toast');
            toast.textContent = msg;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2000);
        }

        function initSampleData() {
            setCellData('A1', '6934114761936');
            setCellData('B1', 'btç”Ÿè„‰é¥®å…šå‚æ–¹ç›¾å…‹åº·ç¦');
            setCellData('C1', '62');
            setCellData('E1', '35');
            setCellData('J1', '240');
            setCellData('K1', '126.8');
            
            document.getElementById('cell-B1').classList.add('cell-yellow');
            document.getElementById('cell-C1').classList.add('cell-yellow');
            
            calculateDColumn();
        }

        function handleGlobalKeydown(e) {
            if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                undo();
            } else if (e.ctrlKey && e.key === 'y') {
                e.preventDefault();
                redo();
            } else if (e.key === 'Delete' && state.selectedCell && !state.editingCell) {
                e.preventDefault();
                clearSelectedCells();
            } else if (e.key === 'F2' && state.selectedCell && !state.editingCell) {
                e.preventDefault();
                startEdit(state.selectedCell);
            } else if (e.key === 'Enter' && state.editingCell) {
                e.preventDefault();
                endEdit();
                moveToNextCell();
            } else if (e.key === 'Escape' && state.editingCell) {
                e.preventDefault();
                const cell = document.getElementById(`cell-${state.editingCell}`);
                cell.textContent = state.data[state.editingCell] || '';
                endEdit();
            }
        }

        function initDragSelection() {
            // æ‹–æ‹½é€‰æ‹©åŠŸèƒ½
        }

        function closeCommentPopup() {
            document.getElementById('commentPopup').classList.remove('show');
            document.getElementById('modalOverlay').classList.remove('show');
        }
    </script>
</body>
</html>
