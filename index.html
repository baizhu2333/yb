<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ™ºèƒ½è¯å“æ•°æ®ç®¡ç†ç³»ç»Ÿ</title>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Microsoft YaHei", "Segoe UI", Arial, sans-serif;
            background: #f5f5f5;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            font-size: 15.44px;
        }

        /* é¡¶éƒ¨å·¥å…·æ  */
        .ribbon {
            background: #fff;
            border-bottom: 1px solid #d4d4d4;
            padding: 9.5px 14.26px;
            display: flex;
            gap: 14.26px;
            align-items: center;
            box-shadow: 0 2.38px 4.75px rgba(0,0,0,0.05);
            z-index: 100;
        }

        .ribbon-group {
            display: flex;
            gap: 7.13px;
            padding-right: 14.26px;
            border-right: 1px solid #e0e0e0;
            align-items: center;
        }

        .ribbon-group:last-child {
            border-right: none;
        }

        .btn {
            padding: 7.13px 16.63px;
            border: 1px solid #d4d4d4;
            background: #fff;
            border-radius: 4.75px;
            cursor: pointer;
            font-size: 15.44px;
            display: flex;
            align-items: center;
            gap: 7.13px;
            transition: all 0.2s;
            color: #333;
            height: 38px;
        }

        .btn:hover {
            background: #f0f0f0;
            border-color: #b4b4b4;
        }

        .btn-primary {
            background: #217346;
            color: white;
            border-color: #217346;
        }

        .btn-primary:hover {
            background: #1e623d;
        }

        .btn-warning {
            background: #ff6b6b;
            color: white;
            border-color: #ff5252;
        }

        .btn-warning:hover {
            background: #ff5252;
        }

        .btn-active {
            background: #84cc16 !important;
            color: white !important;
            border-color: #65a30d !important;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* æ–°å¢ï¼šå¯¼å…¥æ–‡ä»¶åæ˜¾ç¤ºæ ·å¼ */
        .import-filename {
            font-size: 13px;
            color: #666;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding: 0 10px;
            border-left: 1px solid #e0e0e0;
            margin-left: 5px;
        }

        #searchInput {
            width: 356px;
            padding: 0 14.26px;
            border: 1px solid #d4d4d4;
            border-radius: 4.75px;
            font-size: 15.44px;
            height: 38px;
            line-height: 38px;
        }

        #searchInput:focus {
            outline: none;
            border-color: #217346;
            box-shadow: 0 0 0 3.56px rgba(33, 115, 70, 0.1);
        }

        /* è¡¨æ ¼å®¹å™¨ */
        .spreadsheet-container {
            flex: 1;
            overflow: auto;
            position: relative;
            background: #fff;
            transform-origin: top left;
        }

        /* Excelé£æ ¼è¡¨æ ¼ - ä¿®æ”¹ä¸ºautoä»¥æ”¯æŒè‡ªåŠ¨è°ƒæ•´ */
        .sheet-table {
            border-collapse: separate;
            border-spacing: 0;
            table-layout: auto; /* ä¿®æ”¹ï¼šä»fixedæ”¹ä¸ºautoï¼Œæ”¯æŒè‡ªåŠ¨è°ƒæ•´ */
            user-select: none;
            font-size: 15.44px;
            width: auto; /* æ·»åŠ ï¼šè®©è¡¨æ ¼æ ¹æ®å†…å®¹è°ƒæ•´æ€»å®½åº¦ */
        }

        .sheet-table th,
        .sheet-table td {
            border: 1px solid #d4d4d4;
            padding: 0;
            position: relative;
            overflow: hidden;
        }

        /* è¡Œåˆ—å·æ ·å¼ - æ ‡é¢˜è¡Œå­—ä½“å¤§ä¸€å· */
        .sheet-table th {
            background: #f8f9fa;
            color: #666;
            font-weight: 600;
            text-align: center;
            position: sticky;
            z-index: 10;
            font-size: 16.63px;
        }

        .sheet-table th.corner {
            background: #f0f0f0;
            z-index: 20;
            top: 0;
            left: 0;
            width: 43.2px;
            min-width: 43.2px;
        }

        .sheet-table th.col-header {
            top: 0;
            min-width: 95.04px;
            height: 24.73px;
            line-height: 24.73px;
            font-size: 16.63px;
            border-bottom: 2px solid #c0c0c0;
            background: #e5f5d7;
            color: #3f6212;
            white-space: nowrap; /* æ·»åŠ ï¼šé˜²æ­¢æ ‡é¢˜æ¢è¡Œ */
        }

        /* åºå·åˆ— */
        .sheet-table th.row-header {
            left: 0;
            width: 43.2px;
            min-width: 43.2px;
            height: 24.73px;
            line-height: 24.73px;
            font-size: 16.63px;
            border-right: 2px solid #c0c0c0;
            cursor: pointer;
            background: #f0f9e8;
            color: #4d7c0f;
            text-align: left;
            padding-left: 4.32px;
        }

        .sheet-table th.row-header:hover {
            background: #dcfce7;
        }

        /* å•å…ƒæ ¼æ ·å¼ */
        .sheet-table td {
            min-width: 95.04px; /* ä¿®æ”¹ï¼šåªä¿ç•™min-widthï¼Œå»æ‰å›ºå®šwidth */
            height: 24.73px;
            background: #fff;
            cursor: cell;
            white-space: nowrap; /* æ·»åŠ ï¼šé˜²æ­¢å†…å®¹æ¢è¡Œ */
        }

        .cell-content {
            width: 100%;
            height: 100%;
            padding: 2.38px 4.75px;
            font-size: 15.44px;
            line-height: 19.98px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            outline: none;
            border: 2px solid transparent;
            position: relative;
        }

        .cell-content.selected {
            border: 2px solid #217346;
            background: #e8f5e9;
        }

        .cell-content.editing {
            background: #fff;
            border: 2px solid #217346;
            z-index: 100;
            position: relative;
            cursor: text;
            user-select: text;
            white-space: pre;
            overflow: auto;
        }

        /* C-Fåˆ—ä¿æŒå›ºå®šå®½åº¦ - å¼ºåˆ¶ä¸è‡ªåŠ¨è°ƒæ•´ */
        td[data-col="C"], th[data-col="C"],
        td[data-col="D"], th[data-col="D"],
        td[data-col="E"], th[data-col="E"],
        td[data-col="F"], th[data-col="F"] {
            width: 64.8px !important; /* C,Eåˆ— */
            min-width: 64.8px !important;
            max-width: 64.8px !important;
        }

        td[data-col="D"], th[data-col="D"],
        td[data-col="F"], th[data-col="F"] {
            width: 39.96px !important; /* D,Fåˆ— */
            min-width: 39.96px !important;
            max-width: 39.96px !important;
        }

        td[data-col="D"] {
            background: #fcfcec !important;
            cursor: not-allowed !important;
        }

        td.meta-col {
            background: #f9f9f9 !important;
            font-size: 11.88px !important;
            color: #666 !important;
            min-width: 71.28px !important;
        }

        th.meta-col {
            background: #e0e0e0 !important;
            color: #666 !important;
            font-size: 12.96px !important;
            min-width: 71.28px !important;
        }

        /* A-Gåˆ—å­—ä½“å¤§ä¸€å· */
        td[data-col="A"] .cell-content,
        td[data-col="B"] .cell-content,
        td[data-col="C"] .cell-content,
        td[data-col="D"] .cell-content,
        td[data-col="E"] .cell-content,
        td[data-col="F"] .cell-content,
        td[data-col="G"] .cell-content {
            font-size: 17.44px !important;
            line-height: 21.98px !important;
        }

        /* Håˆ—åŠä¹‹åï¼ˆH-ANï¼‰å†…å®¹å­—ä½“è°ƒå°ä¸€å·ï¼ˆ14.44pxï¼‰ï¼Œæ ‡é¢˜ä¿æŒ16.63pxä¸å˜ */
        td[data-col="H"] .cell-content,
        td[data-col="I"] .cell-content,
        td[data-col="J"] .cell-content,
        td[data-col="K"] .cell-content,
        td[data-col="L"] .cell-content,
        td[data-col="M"] .cell-content,
        td[data-col="N"] .cell-content,
        td[data-col="O"] .cell-content,
        td[data-col="P"] .cell-content,
        td[data-col="Q"] .cell-content,
        td[data-col="R"] .cell-content,
        td[data-col="S"] .cell-content,
        td[data-col="T"] .cell-content,
        td[data-col="U"] .cell-content,
        td[data-col="V"] .cell-content,
        td[data-col="W"] .cell-content,
        td[data-col="X"] .cell-content,
        td[data-col="Y"] .cell-content,
        td[data-col="Z"] .cell-content,
        td[data-col="AA"] .cell-content,
        td[data-col="AB"] .cell-content,
        td[data-col="AC"] .cell-content,
        td[data-col="AD"] .cell-content,
        td[data-col="AE"] .cell-content,
        td[data-col="AF"] .cell-content,
        td[data-col="AG"] .cell-content,
        td[data-col="AH"] .cell-content,
        td[data-col="AI"] .cell-content,
        td[data-col="AJ"] .cell-content,
        td[data-col="AK"] .cell-content,
        td[data-col="AL"] .cell-content,
        td[data-col="AM"] .cell-content,
        td[data-col="AN"] .cell-content {
            font-size: 14.44px !important;
            line-height: 18.98px !important;
        }

        /* å¯ç¼–è¾‘æ ‡é¢˜ */
        th.col-header.editable-header {
            cursor: text;
            background: #f0f9e8;
        }

        th.col-header.editable-header:hover {
            background: #dcfce7;
        }

        th.col-header .header-text {
            pointer-events: none;
        }

        th.col-header.editable-header .header-text {
            pointer-events: auto;
        }

        /* Iåˆ—é“¾æ¥æ ·å¼ */
        th[data-col="I"] {
            color: #1976d2 !important;
            text-decoration: underline !important;
            cursor: pointer !important;
        }

        th[data-col="I"]:hover {
            background: #e3f2fd !important;
        }

        /* æ ‡è®°é¢œè‰² */
        .cell-yellow { background-color: #fff200 !important; }
        .cell-red { background-color: #ef5350 !important; color: white !important; }
        .cell-pink { background-color: #f8bbd9 !important; }
        .duplicate-cell { background-color: #ef5350 !important; color: white !important; }
        .search-highlight { background-color: #fef08a !important; }

        /* è¡Œé«˜äº®æ•ˆæœ - æ·¡è“è‰²èƒŒæ™¯ */
        tr.row-highlight td {
            background-color: #e3f2fd !important;
        }

        /* æœ‰é¢œè‰²çš„å•å…ƒæ ¼è·³è¿‡é«˜äº® */
        tr.row-highlight td.cell-yellow,
        tr.row-highlight td.cell-red,
        tr.row-highlight td.cell-pink,
        tr.row-highlight td.duplicate-cell,
        tr.row-highlight td.search-highlight {
            background-color: inherit !important;
        }

        /* åºå·åˆ—é«˜äº® */
        th.row-header.row-highlight {
            background-color: #e3f2fd !important;
        }

        /* å¤‡æ³¨æŒ‡ç¤ºå™¨ */
        .comment-indicator {
            position: absolute;
            top: 1.08px;
            right: 1.08px;
            width: 10.8px;
            height: 10.8px;
            background-color: #ef5350;
            border-radius: 50%;
            z-index: 1;
            pointer-events: none;
        }

        /* å³é”®èœå• */
        .context-menu {
            position: absolute;
            width: 261.36px;
            background: white;
            border: 1px solid #d4d4d4;
            box-shadow: 0 4.75px 14.26px rgba(0,0,0,0.15);
            border-radius: 4.75px;
            padding: 4.75px 0;
            z-index: 10000;
            display: none;
        }

        .context-menu-item {
            padding: 9.5px 19.01px;
            cursor: pointer;
            font-size: 15.44px;
            display: flex;
            align-items: center;
            gap: 9.5px;
        }

        .context-menu-item:hover {
            background-color: #f0f0f0;
        }

        /* æ ‡ç²‰èœå•é¡¹ç‰¹æ®Šæ ·å¼ */
        .context-menu-item.pink-item::before {
            content: '';
            display: inline-block;
            width: 17.28px;
            height: 17.28px;
            background-color: #f8bbd9;
            border-radius: 3.89px;
            margin-right: 4.32px;
        }

        .context-menu-separator {
            height: 1px;
            background-color: #e0e0e0;
            margin: 4.75px 0;
        }

        /* å¤‡æ³¨å¼¹çª— */
        .comment-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #ffffe1;
            border: 2px solid #999;
            border-radius: 9.5px;
            padding: 23.76px;
            font-size: 16.63px;
            min-width: 356px;
            max-width: 594px;
            box-shadow: 0 9.5px 28.51px rgba(0,0,0,0.3);
            z-index: 10001;
            display: none;
            word-wrap: break-word;
            line-height: 1.6;
            color: #333;
        }

        .comment-popup.show {
            display: block;
            animation: popIn 0.3s;
        }

        @keyframes popIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        .comment-popup-close {
            position: absolute;
            top: 9.5px;
            right: 14.26px;
            cursor: pointer;
            font-size: 23.76px;
            color: #666;
        }

        .comment-popup-close:hover {
            color: #000;
        }

        /* æ‚¬åœå¤‡æ³¨æç¤º */
        .comment-tooltip {
            position: fixed;
            background: rgba(51, 51, 51, 0.95);
            color: white;
            padding: 8.64px 12.96px;
            border-radius: 4.32px;
            font-size: 14px;
            max-width: 324px;
            word-wrap: break-word;
            z-index: 10002;
            display: none;
            pointer-events: none;
            box-shadow: 0 2.16px 8.64px rgba(0,0,0,0.2);
        }

        .comment-tooltip.show {
            display: block;
        }

        /* åŠ è½½é®ç½© */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255,255,255,0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            flex-direction: column;
            gap: 23.76px;
        }

        .loading-spinner {
            width: 59.4px;
            height: 59.4px;
            border: 5.94px solid #f3f3f3;
            border-top: 5.94px solid #217346;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .progress-bar {
            width: 356px;
            height: 23.76px;
            background: #e0e0e0;
            border-radius: 11.88px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #217346;
            width: 0%;
            transition: width 0.3s;
        }

        /* Toastæç¤º - å¢å¼ºç‰ˆ */
        .toast {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(51, 51, 51, 0.95);
            color: white;
            padding: 19.01px 38.02px;
            border-radius: 9.5px;
            font-size: 16.63px;
            z-index: 10001;
            display: none;
            box-shadow: 0 4.75px 14.26px rgba(0,0,0,0.3);
            max-width: 500px;
            text-align: center;
            line-height: 1.5;
        }

        .toast.show {
            display: block;
            animation: fadeIn 0.3s;
        }

        .toast.undo-toast {
            background: rgba(33, 115, 70, 0.95);
            border: 2px solid #4ade80;
        }

        .toast.redo-toast {
            background: rgba(30, 64, 175, 0.95);
            border: 2px solid #60a5fa;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        /* é®ç½©å±‚ */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 10000;
            display: none;
        }

        .modal-overlay.show {
            display: block;
        }

        /* éšè—è¡Œæ ·å¼ */
        tr.hidden-row {
            display: none !important;
        }

        /* æ»šåŠ¨æ¡ */
        ::-webkit-scrollbar {
            width: 14.26px;
            height: 14.26px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        ::-webkit-scrollbar-thumb {
            background-color: #c1c1c1;
            border-radius: 7.13px;
            border: 3.56px solid #f1f1f1;
        }

        ::-webkit-scrollbar-thumb:hover {
            background-color: #a1a1a1;
        }

        .hidden { display: none !important; }
    </style>
</head>
<body>

    <!-- åŠ è½½é®ç½© -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
        <div id="loadingText">æ­£åœ¨å¤„ç†...</div>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
    </div>

    <!-- Toastæç¤º -->
    <div class="toast" id="toast"></div>

    <!-- æ‚¬åœå¤‡æ³¨æç¤º -->
    <div class="comment-tooltip" id="commentTooltip"></div>

    <!-- é®ç½©å±‚ -->
    <div class="modal-overlay" id="modalOverlay"></div>

    <!-- å·¥å…·æ  -->
    <div class="ribbon">
        <div class="ribbon-group">
            <input type="text" id="searchInput" placeholder="æœç´¢æ¡ç æˆ–è¯å“åç§°(A/Båˆ—)...">
            <button class="btn" id="clearSearchBtn">æ¸…ç©ºæœç´¢</button>
            <button class="btn" id="filterToggle">ç­›é€‰ï¼0</button>
            <!-- å·²ç§»é™¤è‡ªé€‚åº”åˆ—å®½æŒ‰é’® -->
        </div>

        <div class="ribbon-group">
            <label class="btn btn-primary">
                <span>ğŸ“‚ æ‰“å¼€</span>
                <input type="file" id="fileInput" accept=".xlsx,.xlsm" style="display: none;">
            </label>
            <button class="btn btn-warning" id="saveBtn">ğŸ’¾ ä¿å­˜</button>
        </div>

        <div class="ribbon-group">
            <!-- ä¿®æ”¹ï¼šæ–°å¢è¯å“ï¼ˆåŸæ–°å¢è¡Œï¼‰ -->
            <button class="btn" id="addRowBtn">â• æ–°å¢è¯å“</button>
            <button class="btn" id="undoBtn" disabled>â†©ï¸ è¿”å›ä¸Šä¸€æ­¥</button>
            <button class="btn" id="redoBtn" disabled>â†ªï¸ æ¢å¤ä¸‹ä¸€æ­¥</button>
            <!-- æ–°å¢ï¼šå¯¼å…¥æ–‡ä»¶åæ˜¾ç¤º -->
            <span class="import-filename" id="importFilename" title=""></span>
        </div>

        <div style="flex: 1;"></div>
    </div>

    <!-- è¡¨æ ¼åŒºåŸŸ -->
    <div class="spreadsheet-container" id="container">
        <table class="sheet-table" id="sheetTable">
            <thead id="tableHead"></thead>
            <tbody id="tableBody"></tbody>
        </table>
    </div>

    <!-- å³é”®èœå• -->
    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item" onclick="addComment()">ğŸ“ æ·»åŠ /ç¼–è¾‘å¤‡æ³¨</div>
        <div class="context-menu-item" onclick="clearComment()">ğŸ—‘ï¸ æ¸…é™¤å¤‡æ³¨</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" onclick="formatCell('red')">ğŸŸ¥ çº¢è‰²ï¼ˆæœ‰é—®é¢˜ï¼‰</div>
        <div class="context-menu-item" onclick="formatCell('yellow')">ğŸŸ¨ æ ‡é»„ï¼ˆè¡¥è¯ï¼‰</div>
        <div class="context-menu-item pink-item" onclick="formatCell('pink')">æ ‡ç²‰ï¼ˆå¦‡ç§‘ï¼‰</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" onclick="clearCellFormat()">â¬œ æ¸…é™¤é¢œè‰²</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" onclick="deleteSelectedRow()">ğŸ—‘ï¸ åˆ é™¤æ•´è¡Œ</div>
        <div class="context-menu-item" onclick="clearSelectedCells()">âŒ« æ¸…ç©ºå†…å®¹</div>
    </div>

    <!-- å¤‡æ³¨å¼¹çª— -->
    <div class="comment-popup" id="commentPopup">
        <span class="comment-popup-close" onclick="closeCommentPopup()">Ã—</span>
        <div id="commentPopupContent"></div>
    </div>

    <script>
        // ==================== é…ç½® ====================
        const CONFIG = {
            maxCol: 'AN',
            dataMaxCol: 'T',
            readOnlyCol: ['D'],
            calcHeaderCol: 'L',
            editableHeaders: ['H', 'I', 'J', 'K'],
            formulaHeaders: ['J', 'K'],
            traceCodeCol: ['H','I','M','N'],
            countColForD: [],
            noMetaCols: ['C', 'D', 'E', 'F', 'G'],
            noResizeCols: ['C', 'D', 'E', 'F'], // C-Fåˆ—ä¸è‡ªåŠ¨è°ƒæ•´
            storageKey: 'medicine_excel_data_v2_6',
            metaDataSeparator: '|',
            batchSize: 50,
            maxHistory: 20,
            debounceDelay: 300,
            importChunkSize: 100,
            searchJumpStartCol: 'H',
            minColWidth: 50, // æœ€å°åˆ—å®½
            maxColWidth: 400 // æœ€å¤§åˆ—å®½
        };

        for(let i='H'.charCodeAt(0); i<='T'.charCodeAt(0); i++) {
            CONFIG.countColForD.push(String.fromCharCode(i));
        }

        // ==================== çŠ¶æ€ç®¡ç† ====================
        const state = {
            rows: 100,
            cols: 40,
            data: {},
            headerData: {},
            selectedCell: null,
            selectedCells: new Set(),
            editingCell: null,
            isFilterActive: false,
            searchTerm: '',
            filteredRows: new Set(),
            originalData: [],
            historyStack: [],
            redoStack: [],
            isUndoRedo: false,
            isProcessing: false,
            colLetters: [],
            dragStartCell: null,
            isDragging: false,
            lastClickTime: 0,
            lastRightClickTime: 0,
            activeInput: null,
            editingHeader: null,
            highlightedRow: null,
            lastAction: null,
            scrollPosition: { top: 0, left: 0 },
            colWidths: {}, // å­˜å‚¨å„åˆ—è®¡ç®—åçš„å®½åº¦
            originalRowOrder: [], // å­˜å‚¨åŸå§‹è¡Œé¡ºåºï¼Œç”¨äºæ¢å¤
            lastImportFilename: '' // æ–°å¢ï¼šå­˜å‚¨æœ€åå¯¼å…¥çš„æ–‡ä»¶å
        };

        const ACTION_TYPES = {
            EDIT_CELL: 'ç¼–è¾‘å•å…ƒæ ¼',
            EDIT_HEADER: 'ä¿®æ”¹æ ‡é¢˜',
            ADD_ROW: 'æ–°å¢è¡Œ',
            DELETE_ROW: 'åˆ é™¤è¡Œ',
            FORMAT_CELL: 'æ ¼å¼åŒ–å•å…ƒæ ¼',
            ADD_COMMENT: 'æ·»åŠ å¤‡æ³¨',
            CLEAR_COMMENT: 'æ¸…é™¤å¤‡æ³¨',
            CLEAR_CONTENT: 'æ¸…ç©ºå†…å®¹',
            IMPORT: 'å¯¼å…¥æ•°æ®',
            FILTER: 'ç­›é€‰æ•°æ®',
            SEARCH: 'æœç´¢æ•°æ®',
            DELETE_MULTI: 'æ‰¹é‡åˆ é™¤',
            FORMAT_MULTI: 'æ‰¹é‡æ ¼å¼åŒ–',
            CLEAR_MULTI: 'æ‰¹é‡æ¸…ç©º',
            RESIZE_COLS: 'è°ƒæ•´åˆ—å®½'
        };

        function generateColLetters() {
            const letters = [];
            for (let i = 0; i < 26; i++) letters.push(String.fromCharCode(65 + i));
            for (let i = 0; i < 14; i++) letters.push('A' + String.fromCharCode(65 + i));
            return letters;
        }

        document.addEventListener('DOMContentLoaded', () => {
            state.colLetters = generateColLetters();
            initTable();
            initEvents();
            initSampleData();
            loadFromLocalStorage();
            // åˆå§‹åŒ–åè‡ªåŠ¨è°ƒæ•´ä¸€æ¬¡åˆ—å®½
            setTimeout(() => autoResizeColumns(), 100);
            saveToHistory('åˆå§‹åŒ–', null);
        });

        function initTable() {
            const thead = document.getElementById('tableHead');
            const tbody = document.getElementById('tableBody');
            
            const headerText = {
                A: 'æ¡ç ', B: 'è¯å“åç§°', C: 'ä»·', D: 'æ— ç©º', E: 'hyj', F: 'ä¸Šé™', G: 'å¤‡æ³¨',
                H: 'Q02000000', I: 'ç‚¹å‡»è®¿é—®ç½‘ç«™', J: '240', K: '126.8', L: 'è®¡ç®—å€¼',
                M: '', N: '', O: '', P: '', Q: '', R: '', S: '', T: '',
                U: 'Aå…ƒ', V: 'Bå…ƒ', W: 'Cå…ƒ', X: 'Då…ƒ', Y: 'Eå…ƒ', Z: 'Få…ƒ',
                AA: 'Gå…ƒ', AB: 'Hå…ƒ', AC: 'Iå…ƒ', AD: 'Jå…ƒ', AE: 'Kå…ƒ', AF: 'Lå…ƒ',
                AG: 'Må…ƒ', AH: 'Nå…ƒ', AI: 'Oå…ƒ', AJ: 'På…ƒ', AK: 'Qå…ƒ', AL: 'Rå…ƒ',
                AM: 'Så…ƒ', AN: 'Tå…ƒ'
            };

            state.colLetters.forEach(col => {
                state.headerData[col] = headerText[col] || col;
            });

            let headerHTML = '<tr><th class="corner"></th>';
            state.colLetters.forEach((col, idx) => {
                const isMeta = idx >= 20;
                const isEditable = CONFIG.editableHeaders.includes(col);
                const isI = col === 'I';
                const text = state.headerData[col];
                let width = getColWidth(col, idx);
                const classes = ['col-header'];
                if (isMeta) classes.push('meta-col');
                if (isEditable || isI) classes.push('editable-header');
                const clickHandler = isI ? 'onclick="openWebsite()"' : 
                                   (isEditable ? 'onclick="editHeader(\'' + col + '\')"' : '');
                // æ·»åŠ åˆ—æ ‡é¢˜å±æ€§ç”¨äºè‡ªåŠ¨è°ƒæ•´
                headerHTML += `<th class="${classes.join(' ')}" data-col="${col}" data-idx="${idx}" style="min-width: ${width}px;" ${clickHandler}>
                    <span class="header-text">${text}</span>
                </th>`;
            });
            headerHTML += '</tr>';
            thead.innerHTML = headerHTML;
            renderEmptyRows();
            calculateLHeader();
        }

        function getColWidth(col, idx) {
            if (col === 'A') return 145.8;
            if (col === 'C' || col === 'E') return 64.8;
            if (col === 'D' || col === 'F') return 39.96;
            if (idx >= 7 && idx <= 19) return 173.88;
            if (idx >= 20) return 71.28;
            return 118.8;
        }

        function renderEmptyRows() {
            const tbody = document.getElementById('tableBody');
            let bodyHTML = '';
            for (let r = 0; r < state.rows; r++) {
                bodyHTML += `<tr data-row-num="${r + 1}"><th class="row-header" onclick="selectRow(${r})">${r + 1}</th>`;
                state.colLetters.forEach((col, idx) => {
                    const isMeta = idx >= 20;
                    const isReadOnly = CONFIG.readOnlyCol.includes(col);
                    const cellId = `${col}${r + 1}`;
                    // C-Fåˆ—ä½¿ç”¨å›ºå®šå®½åº¦ï¼Œå…¶ä»–åˆ—ä½¿ç”¨min-widthæ”¯æŒè‡ªåŠ¨è°ƒæ•´
                    const isFixed = CONFIG.noResizeCols.includes(col);
                    const width = getColWidth(col, idx);
                    const widthStyle = isFixed ? `width: ${width}px; min-width: ${width}px; max-width: ${width}px;` : `min-width: ${width}px;`;
                    
                    bodyHTML += `
                        <td data-row="${r}" data-col="${col}" data-id="${cellId}" 
                            class="${isMeta ? 'meta-col' : ''} ${isReadOnly ? '' : 'editable'}"
                            style="${widthStyle}"
                            onclick="handleCellClick(event, '${cellId}')"
                            onmouseenter="highlightRow(${r}); showCommentTooltip(event, '${cellId}')"
                            onmouseleave="clearHighlight(); hideCommentTooltip()">
                            <div class="cell-content" id="cell-${cellId}"></div>
                        </td>
                    `;
                });
                bodyHTML += '</tr>';
            }
            tbody.innerHTML = bodyHTML;
        }

        // ==================== è‡ªåŠ¨è°ƒæ•´åˆ—å®½åŠŸèƒ½ï¼ˆè‡ªåŠ¨æ‰§è¡Œï¼Œæ— éœ€æŒ‰é’®ï¼‰ ====================
        function autoResizeColumns() {
            // åˆ›å»ºä¸´æ—¶canvasç”¨äºæµ‹é‡æ–‡æœ¬å®½åº¦
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            // è®¾ç½®å­—ä½“ä»¥åŒ¹é…å•å…ƒæ ¼æ ·å¼
            context.font = '15.44px "Microsoft YaHei", "Segoe UI", Arial, sans-serif';
            
            const headerContext = canvas.getContext('2d');
            headerContext.font = 'bold 16.63px "Microsoft YaHei", "Segoe UI", Arial, sans-serif';
            
            // ä¸ºæ¯ä¸ªåˆ—è®¡ç®—æœ€å¤§å®½åº¦
            state.colLetters.forEach((col, idx) => {
                // è·³è¿‡C-Fåˆ—ï¼ˆå›ºå®šå®½åº¦ï¼‰
                if (CONFIG.noResizeCols.includes(col)) return;
                
                let maxWidth = getColWidth(col, idx); // é»˜è®¤æœ€å°å®½åº¦
                const isMeta = idx >= 20;
                const fontSize = isMeta ? 11.88 : (['A','B','C','D','E','F','G'].includes(col) ? 17.44 : 15.44);
                context.font = `${fontSize}px "Microsoft YaHei", "Segoe UI", Arial, sans-serif`;
                
                // 1. æµ‹é‡æ ‡é¢˜å®½åº¦
                const headerText = state.headerData[col] || col;
                const headerWidth = headerContext.measureText(headerText).width;
                maxWidth = Math.max(maxWidth, headerWidth + 20); // åŠ padding
                
                // 2. æµ‹é‡è¯¥åˆ—æ‰€æœ‰å•å…ƒæ ¼å†…å®¹å®½åº¦
                for (let r = 1; r <= state.rows; r++) {
                    const cellId = `${col}${r}`;
                    const value = state.data[cellId] || '';
                    if (value) {
                        const textWidth = context.measureText(value).width;
                        maxWidth = Math.max(maxWidth, textWidth + 20); // åŠ padding
                    }
                }
                
                // 3. åº”ç”¨æœ€å¤§/æœ€å°é™åˆ¶
                maxWidth = Math.max(CONFIG.minColWidth, Math.min(maxWidth, CONFIG.maxColWidth));
                
                // 4. åº”ç”¨å®½åº¦åˆ°è¡¨æ ¼
                const th = document.querySelector(`th[data-col="${col}"]`);
                const tds = document.querySelectorAll(`td[data-col="${col}"]`);
                
                if (th) {
                    th.style.width = maxWidth + 'px';
                    th.style.minWidth = maxWidth + 'px';
                }
                tds.forEach(td => {
                    td.style.width = maxWidth + 'px';
                    td.style.minWidth = maxWidth + 'px';
                });
                
                state.colWidths[col] = maxWidth;
            });
            
            showToast('åˆ—å®½å·²è‡ªåŠ¨è°ƒæ•´');
        }

        // è°ƒæ•´å•åˆ—å®½åº¦
        function resizeSingleColumn(col) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const idx = state.colLetters.indexOf(col);
            const isMeta = idx >= 20;
            const fontSize = isMeta ? 11.88 : (['A','B','C','D','E','F','G'].includes(col) ? 17.44 : 15.44);
            context.font = `${fontSize}px "Microsoft YaHei", "Segoe UI", Arial, sans-serif`;
            
            let maxWidth = getColWidth(col, idx);
            
            // æµ‹é‡æ ‡é¢˜
            const headerText = state.headerData[col] || col;
            const headerWidth = context.measureText(headerText).width;
            maxWidth = Math.max(maxWidth, headerWidth + 20);
            
            // æµ‹é‡å†…å®¹
            for (let r = 1; r <= state.rows; r++) {
                const cellId = `${col}${r}`;
                const value = state.data[cellId] || '';
                if (value) {
                    const textWidth = context.measureText(value).width;
                    maxWidth = Math.max(maxWidth, textWidth + 20);
                }
            }
            
            maxWidth = Math.max(CONFIG.minColWidth, Math.min(maxWidth, CONFIG.maxColWidth));
            
            const th = document.querySelector(`th[data-col="${col}"]`);
            const tds = document.querySelectorAll(`td[data-col="${col}"]`);
            
            if (th) {
                th.style.width = maxWidth + 'px';
                th.style.minWidth = maxWidth + 'px';
            }
            tds.forEach(td => {
                td.style.width = maxWidth + 'px';
                td.style.minWidth = maxWidth + 'px';
            });
            
            state.colWidths[col] = maxWidth;
        }

        function highlightRow(rowIdx) {
            clearHighlight();
            state.highlightedRow = rowIdx;
            const row = document.querySelectorAll('#tableBody tr')[rowIdx];
            if (!row || row.classList.contains('hidden-row')) return;
            row.classList.add('row-highlight');
            const rowHeader = row.querySelector('.row-header');
            if (rowHeader) rowHeader.classList.add('row-highlight');
        }

        function clearHighlight() {
            document.querySelectorAll('.row-highlight').forEach(el => {
                el.classList.remove('row-highlight');
            });
            state.highlightedRow = null;
        }

        function editHeader(col) {
            if (state.editingHeader) return;
            const th = document.querySelector(`th[data-col="${col}"]`);
            const currentText = state.headerData[col];
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentText;
            input.style.cssText = 'width: 100%; height: 100%; border: none; outline: 2px solid #217346; padding: 2px; font-size: 14px; font-weight: bold; text-align: center;';
            const span = th.querySelector('.header-text');
            span.style.display = 'none';
            th.appendChild(input);
            input.focus();
            input.select();
            state.editingHeader = col;
            const finishEdit = () => {
                const newValue = input.value.trim();
                if (newValue && newValue !== currentText) {
                    const oldValue = state.headerData[col];
                    state.headerData[col] = newValue;
                    span.textContent = newValue;
                    if (CONFIG.formulaHeaders.includes(col)) {
                        calculateLHeader();
                    }
                    // æ ‡é¢˜ä¿®æ”¹åè‡ªåŠ¨è°ƒæ•´è¯¥åˆ—å®½åº¦
                    if (!CONFIG.noResizeCols.includes(col)) {
                        setTimeout(() => resizeSingleColumn(col), 0);
                    }
                    saveToHistory(ACTION_TYPES.EDIT_HEADER, { col, oldValue, newValue, cellId: `header-${col}` });
                } else {
                    span.textContent = currentText;
                }
                input.remove();
                span.style.display = '';
                state.editingHeader = null;
            };
            input.addEventListener('blur', finishEdit);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    finishEdit();
                } else if (e.key === 'Escape') {
                    input.remove();
                    span.style.display = '';
                    state.editingHeader = null;
                }
            });
        }

        function calculateLHeader() {
            const jVal = parseFloat(state.headerData['J']) || 0;
            const kVal = parseFloat(state.headerData['K']) || 0;
            const lVal = (jVal - kVal).toFixed(1);
            state.headerData['L'] = lVal;
            const thL = document.querySelector(`th[data-col="L"] .header-text`);
            if (thL) thL.textContent = lVal;
        }

        function openWebsite() {
            window.open('https://www.mashangfangxin.com/', '_blank', 'noopener,noreferrer');
        }

        function initEvents() {
            const searchInput = document.getElementById('searchInput');
            searchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    performSearch();
                }
            });
            
            document.getElementById('tableBody').addEventListener('dblclick', (e) => {
                const td = e.target.closest('td[data-col]');
                if (!td) return;
                const cellId = td.dataset.id;
                const col = cellId.match(/[A-Z]+/)[0];
                if (CONFIG.readOnlyCol.includes(col) || isMetaCol(col)) return;
                e.preventDefault();
                selectCell(cellId);
                startEdit(cellId, e);
            });
            
            document.getElementById('clearSearchBtn').addEventListener('click', clearSearch);
            document.getElementById('filterToggle').addEventListener('click', toggleFilter);
            document.getElementById('fileInput').addEventListener('change', handleExcelImport);
            document.getElementById('saveBtn').addEventListener('click', saveToExcel);
            document.getElementById('addRowBtn').addEventListener('click', handleAddRowClick);
            document.getElementById('undoBtn').addEventListener('click', undo);
            document.getElementById('redoBtn').addEventListener('click', redo);
            // å·²ç§»é™¤ï¼šdocument.getElementById('autoResizeBtn').addEventListener('click', autoResizeColumns);
            
            document.addEventListener('keydown', handleGlobalKeydown);
            document.addEventListener('contextmenu', handleGlobalRightClick);
            document.addEventListener('mousedown', (e) => {
                const menu = document.getElementById('contextMenu');
                if (menu.style.display === 'block' && !e.target.closest('.context-menu')) {
                    menu.style.display = 'none';
                }
            });
            const container = document.getElementById('container');
            container.addEventListener('scroll', () => {
                if (!state.isUndoRedo) {
                    state.scrollPosition = {
                        top: container.scrollTop,
                        left: container.scrollLeft
                    };
                }
            });
            window.addEventListener('beforeunload', saveToLocalStorage);
            
            // åˆå§‹åŒ–åˆ—æ ‡é¢˜åŒå‡»äº‹ä»¶
            setTimeout(() => initColumnResizeEvents(), 100);
        }

        function handleAddRowClick() {
            const container = document.getElementById('container');
            const scrollHeight = container.scrollHeight;
            const clientHeight = container.clientHeight;
            const scrollTop = container.scrollTop;
            const isAtBottom = scrollTop + clientHeight >= scrollHeight - 10;
            if (!isAtBottom) {
                container.scrollTop = scrollHeight;
            } else {
                addNewRow();
            }
        }

        function showCommentTooltip(e, cellId) {
            const cell = document.getElementById(`cell-${cellId}`);
            const comment = cell.dataset.comment;
            if (comment) {
                const tooltip = document.getElementById('commentTooltip');
                tooltip.textContent = comment;
                tooltip.style.left = (e.clientX + 10) + 'px';
                tooltip.style.top = (e.clientY + 10) + 'px';
                tooltip.classList.add('show');
            }
        }

        function hideCommentTooltip() {
            const tooltip = document.getElementById('commentTooltip');
            tooltip.classList.remove('show');
        }

        function handleGlobalRightClick(e) {
            const cell = e.target.closest('td[data-col]');
            if (!cell) return;
            const currentTime = new Date().getTime();
            const timeDiff = currentTime - state.lastRightClickTime;
            if (timeDiff < 300) {
                e.preventDefault();
                e.stopPropagation();
                const cellId = cell.dataset.id;
                selectCell(cellId);
                showContextMenu(e, cellId);
                state.lastRightClickTime = 0;
            } else {
                state.lastRightClickTime = currentTime;
            }
        }

        // ==================== ä¿®å¤ï¼šæœç´¢åŠŸèƒ½ï¼ˆç­›é€‰çŠ¶æ€ä¸‹åªæ˜¾ç¤ºæœç´¢ç»“æœï¼‰ ====================
        function performSearch() {
            const term = document.getElementById('searchInput').value.trim().toLowerCase();
            const previousTerm = state.searchTerm;
            const previousFilterState = state.isFilterActive;
            
            if (!term) {
                clearSearch();
                return;
            }
            
            state.searchTerm = term;
            
            // æ¸…é™¤ä¹‹å‰çš„é«˜äº®
            document.querySelectorAll('.search-highlight').forEach(el => {
                el.classList.remove('search-highlight');
            });
            
            state.filteredRows.clear();
            
            // æ˜¾ç¤ºæ‰€æœ‰è¡Œï¼ˆé‡ç½®ç­›é€‰ï¼‰
            document.querySelectorAll('#tableBody tr').forEach(tr => {
                tr.classList.remove('hidden-row');
            });
            
            // æ”¶é›†åŒ¹é…çš„è¡Œ
            const matchedRows = [];
            for (let r = 1; r <= state.rows; r++) {
                const aVal = (state.data[`A${r}`] || '').toLowerCase();
                const bVal = (state.data[`B${r}`] || '').toLowerCase();
                
                if (aVal.includes(term) || bVal.includes(term)) {
                    state.filteredRows.add(r);
                    matchedRows.push(r);
                    
                    // æ·»åŠ é«˜äº®
                    if (aVal.includes(term)) {
                        const cellA = document.getElementById(`cell-A${r}`);
                        if (cellA) cellA.classList.add('search-highlight');
                    }
                    if (bVal.includes(term)) {
                        const cellB = document.getElementById(`cell-B${r}`);
                        if (cellB) cellB.classList.add('search-highlight');
                    }
                }
            }
            
            // åªæ ¹æ®æœç´¢ç»“æœéšè—è¡Œï¼ˆä¸å åŠ ç­›é€‰æ¡ä»¶ï¼‰
            for (let r = 1; r <= state.rows; r++) {
                const row = document.querySelector(`tr[data-row-num="${r}"]`);
                if (!state.filteredRows.has(r)) {
                    row.classList.add('hidden-row');
                } else {
                    row.classList.remove('hidden-row');
                }
            }
            
            // å¦‚æœä¹‹å‰æœ‰ç­›é€‰çŠ¶æ€ï¼Œå…³é—­å®ƒï¼ˆå› ä¸ºæœç´¢ä¼˜å…ˆçº§æ›´é«˜ï¼‰
            if (state.isFilterActive) {
                state.isFilterActive = false;
                const filterBtn = document.getElementById('filterToggle');
                filterBtn.classList.remove('btn-active');
                filterBtn.textContent = 'ç­›é€‰ï¼0';
            }
            
            saveToHistory(ACTION_TYPES.SEARCH, { 
                term, 
                previousTerm, 
                previousFilterState,
                resultCount: state.filteredRows.size,
                filteredRows: Array.from(state.filteredRows)
            });
            
            showToast(`æ‰¾åˆ° ${state.filteredRows.size} ä¸ªåŒ¹é…é¡¹`);
            
            // è·³è½¬åˆ°ç¬¬ä¸€ä¸ªåŒ¹é…è¡Œçš„Håˆ—ç©ºå•å…ƒæ ¼
            if (matchedRows.length > 0) {
                setTimeout(() => {
                    jumpToFirstEmptyCellFromH(matchedRows[0]);
                }, 100);
            }
        }

        // ==================== ä¿®å¤ï¼šæ¸…ç©ºæœç´¢åŠŸèƒ½ ====================
        function clearSearch() {
            const previousTerm = state.searchTerm;
            const previousFilterState = state.isFilterActive;
            
            document.getElementById('searchInput').value = '';
            state.searchTerm = '';
            state.filteredRows.clear();
            
            document.querySelectorAll('.search-highlight').forEach(el => {
                el.classList.remove('search-highlight');
            });
            
            // æ¢å¤åŸå§‹è¡Œé¡ºåºï¼ˆå¦‚æœä¹‹å‰æœ‰æ’åºï¼‰
            restoreOriginalRowOrder();
            
            // æ˜¾ç¤ºæ‰€æœ‰è¡Œï¼ˆå›åˆ°é¦–é¡µï¼‰
            document.querySelectorAll('#tableBody tr').forEach(tr => {
                tr.classList.remove('hidden-row');
            });
            
            // å¦‚æœä¹‹å‰æœ‰ç­›é€‰çŠ¶æ€ï¼Œé‡æ–°åº”ç”¨
            if (state.isFilterActive) {
                applyFilter();
            }
            
            if (previousTerm || previousFilterState !== state.isFilterActive) {
                saveToHistory(ACTION_TYPES.SEARCH, { 
                    term: '', 
                    previousTerm, 
                    previousFilterState,
                    resultCount: 0,
                    filteredRows: []
                });
            }
            
            const container = document.getElementById('container');
            container.scrollTop = 0;
            container.scrollLeft = 0;
            selectCell('A1');
        }

        // æ¢å¤åŸå§‹è¡Œé¡ºåº
        function restoreOriginalRowOrder() {
            const tbody = document.getElementById('tableBody');
            const rows = Array.from(tbody.querySelectorAll('tr'));
            
            // æŒ‰data-row-numæ’åº
            rows.sort((a, b) => {
                const numA = parseInt(a.dataset.rowNum);
                const numB = parseInt(b.dataset.rowNum);
                return numA - numB;
            });
            
            // é‡æ–°æ·»åŠ åˆ°tbody
            rows.forEach(row => tbody.appendChild(row));
        }

        function jumpToFirstEmptyCellFromH(rowNum) {
            const startColIndex = state.colLetters.indexOf(CONFIG.searchJumpStartCol);
            for (let i = startColIndex; i < state.colLetters.length; i++) {
                const col = state.colLetters[i];
                if (CONFIG.readOnlyCol.includes(col) || isMetaCol(col)) continue;
                const cellId = `${col}${rowNum}`;
                const cellValue = state.data[cellId];
                if (!cellValue || cellValue.trim() === '') {
                    const cell = document.getElementById(`cell-${cellId}`);
                    if (!cell) continue;
                    const row = cell.closest('tr');
                    if (row && row.classList.contains('hidden-row')) continue;
                    cell.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    setTimeout(() => {
                        selectCell(cellId);
                        startEdit(cellId, null);
                    }, 300);
                    return;
                }
            }
            const firstCellId = `${CONFIG.searchJumpStartCol}${rowNum}`;
            const firstCell = document.getElementById(`cell-${firstCellId}`);
            if (firstCell) {
                firstCell.scrollIntoView({ behavior: 'smooth', block: 'center' });
                setTimeout(() => {
                    selectCell(firstCellId);
                    startEdit(firstCellId, null);
                }, 300);
            }
        }

        function toggleFilter() {
            const previousState = state.isFilterActive;
            const previousSearchTerm = state.searchTerm;
            const previousFilteredRows = Array.from(state.filteredRows);
            state.isFilterActive = !state.isFilterActive;
            const btn = document.getElementById('filterToggle');
            btn.classList.toggle('btn-active', state.isFilterActive);
            if (state.isFilterActive) {
                btn.textContent = 'æ˜¾ç¤ºå…¨éƒ¨';
                // æ¸…ç©ºæœç´¢
                state.searchTerm = '';
                document.getElementById('searchInput').value = '';
                document.querySelectorAll('.search-highlight').forEach(el => {
                    el.classList.remove('search-highlight');
                });
                state.filteredRows.clear();
                applyFilter();
            } else {
                btn.textContent = 'ç­›é€‰ï¼0';
                clearFilter();
            }
            saveToHistory(ACTION_TYPES.FILTER, { 
                active: state.isFilterActive, 
                previousState,
                previousSearchTerm,
                previousFilteredRows
            });
        }

        // ==================== æ–°å¢ï¼šç­›é€‰åæŒ‰Cåˆ—é™åºæ’åº ====================
        function applyFilter(keepSearchHighlight = false) {
            // è·å–æ‰€æœ‰D>0çš„è¡Œ
            const visibleRows = [];
            for (let r = 1; r <= state.rows; r++) {
                const dVal = parseInt(state.data[`D${r}`] || '0');
                if (dVal > 0) {
                    const cVal = parseFloat(state.data[`C${r}`] || '0');
                    visibleRows.push({ rowNum: r, cValue: cVal });
                }
            }
            
            // æŒ‰Cåˆ—æ•°å€¼ä»å¤§åˆ°å°æ’åº
            visibleRows.sort((a, b) => b.cValue - a.cValue);
            
            // è·å–tbodyå¹¶é‡æ–°æ’åˆ—è¡Œ
            const tbody = document.getElementById('tableBody');
            const rowsMap = new Map();
            
            // æ”¶é›†æ‰€æœ‰è¡Œ
            for (let r = 1; r <= state.rows; r++) {
                const row = document.querySelector(`tr[data-row-num="${r}"]`);
                if (row) {
                    rowsMap.set(r, row);
                }
            }
            
            // æ¸…ç©ºtbody
            tbody.innerHTML = '';
            
            // æŒ‰æ’åºåçš„é¡ºåºæ·»åŠ å¯è§è¡Œ
            visibleRows.forEach(({ rowNum }) => {
                const row = rowsMap.get(rowNum);
                if (row) {
                    row.classList.remove('hidden-row');
                    tbody.appendChild(row);
                }
            });
            
            // æ·»åŠ éšè—çš„è¡Œï¼ˆä¿æŒåŸå§‹é¡ºåºï¼‰
            for (let r = 1; r <= state.rows; r++) {
                if (!visibleRows.some(v => v.rowNum === r)) {
                    const row = rowsMap.get(r);
                    if (row) {
                        row.classList.add('hidden-row');
                        tbody.appendChild(row);
                    }
                }
            }
            
            if (!keepSearchHighlight) {
                showToast(`ç­›é€‰æ˜¾ç¤º ${visibleRows.length} è¡Œï¼Œå·²æŒ‰Cåˆ—é™åºæ’åˆ—`);
            }
        }

        function clearFilter() {
            // æ¢å¤åŸå§‹è¡Œé¡ºåº
            restoreOriginalRowOrder();
            
            // æ˜¾ç¤ºæ‰€æœ‰è¡Œ
            document.querySelectorAll('#tableBody tr').forEach(tr => {
                tr.classList.remove('hidden-row');
            });
            
            // å¦‚æœæœ‰æœç´¢è¯ï¼Œé‡æ–°åº”ç”¨æœç´¢
            if (state.searchTerm) {
                performSearch();
            }
        }

        function handleCellClick(e, cellId) {
            e.stopPropagation();
            const cell = document.getElementById(`cell-${cellId}`);
            const td = cell.parentElement;
            if (e.ctrlKey) {
                toggleCellSelection(td);
            } else if (e.shiftKey && state.selectedCell) {
                selectCellRange(state.selectedCell, cellId);
            } else {
                selectCell(cellId);
                if (td.classList.contains('editable') && !td.classList.contains('meta-col')) {
                    startEdit(cellId, e);
                }
            }
        }

        function selectCell(cellId) {
            document.querySelectorAll('.cell-content.selected').forEach(el => {
                el.classList.remove('selected');
            });
            document.querySelectorAll('tr.row-selected').forEach(tr => {
                tr.classList.remove('row-selected');
            });
            state.selectedCells.clear();
            state.selectedCell = cellId;
            const cell = document.getElementById(`cell-${cellId}`);
            if (cell) {
                cell.classList.add('selected');
                cell.focus();
            }
        }

        function selectRow(rowIdx) {
            clearAllSelections();
            const row = document.querySelectorAll('#tableBody tr')[rowIdx];
            if (row.classList.contains('hidden-row')) return;
            row.classList.add('row-selected');
            const editableCells = row.querySelectorAll('td.editable');
            editableCells.forEach(cell => {
                state.selectedCells.add(cell.dataset.id);
                cell.querySelector('.cell-content').classList.add('selected');
            });
            if (editableCells.length > 0) {
                selectCell(editableCells[0].dataset.id);
            }
        }

        function toggleCellSelection(td) {
            const cellId = td.dataset.id;
            const cell = td.querySelector('.cell-content');
            if (state.selectedCells.has(cellId)) {
                state.selectedCells.delete(cellId);
                cell.classList.remove('selected');
            } else {
                state.selectedCells.add(cellId);
                cell.classList.add('selected');
                state.selectedCell = cellId;
            }
        }

        function selectCellRange(startId, endId) {
            clearAllSelections();
            selectCell(endId);
        }

        function clearAllSelections() {
            document.querySelectorAll('.cell-content.selected').forEach(el => {
                el.classList.remove('selected');
            });
            document.querySelectorAll('tr.row-selected').forEach(tr => {
                tr.classList.remove('row-selected');
            });
            state.selectedCells.clear();
        }

        function startEdit(cellId, clickEvent) {
            if (state.editingCell) endEdit();
            const rowMatch = cellId.match(/(\d+)$/);
            if (!rowMatch) return;
            const displayRow = parseInt(rowMatch[1]);
            const row = document.querySelector(`tr[data-row-num="${displayRow}"]`);
            if (row && row.classList.contains('hidden-row')) {
                return;
            }
            state.editingCell = cellId;
            const cell = document.getElementById(`cell-${cellId}`);
            const currentContent = cell.innerHTML;
            const hasIndicator = cell.querySelector('.comment-indicator');
            cell.contentEditable = true;
            cell.classList.add('editing');
            cell.focus();
            if (clickEvent && clickEvent.type === 'dblclick') {
                const selection = window.getSelection();
                const range = document.createRange();
                range.selectNodeContents(cell);
                selection.removeAllRanges();
                selection.addRange(range);
            }
            if (hasIndicator) {
                cell.innerHTML = currentContent;
            }
            if (clickEvent && clickEvent.type !== 'dblclick' && clickEvent.clientX) {
                const range = document.caretRangeFromPoint(clickEvent.clientX, clickEvent.clientY);
                if (range) {
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                }
            } else if (!clickEvent) {
                const selection = window.getSelection();
                const range = document.createRange();
                range.selectNodeContents(cell);
                selection.removeAllRanges();
                selection.addRange(range);
            }
            state.activeInput = cell;
        }

        function endEdit() {
            if (!state.editingCell) return;
            const cellId = state.editingCell;
            const cell = document.getElementById(`cell-${cellId}`);
            const indicator = cell.querySelector('.comment-indicator');
            if (indicator) indicator.remove();
            const value = cell.textContent;
            const oldValue = state.data[cellId] || '';
            if (cell.dataset.comment) {
                if (!cell.querySelector('.comment-indicator')) {
                    const newIndicator = document.createElement('div');
                    newIndicator.className = 'comment-indicator';
                    cell.appendChild(newIndicator);
                }
            }
            if (value !== oldValue) {
                setCellData(cellId, value, false);
                const col = cellId.match(/[A-Z]+/)[0];
                if (isDataCol(col) && !CONFIG.noMetaCols.includes(col)) {
                    syncMetaData(cellId);
                }
                calculateDColumn();
                checkDuplicates();
                // ç¼–è¾‘åè‡ªåŠ¨è°ƒæ•´è¯¥åˆ—å®½åº¦ï¼ˆå¦‚æœä¸æ˜¯C-Fåˆ—ï¼‰
                if (!CONFIG.noResizeCols.includes(col)) {
                    setTimeout(() => resizeSingleColumn(col), 0);
                }
                saveToHistory(ACTION_TYPES.EDIT_CELL, { 
                    cellId, 
                    oldValue, 
                    newValue: value,
                    col,
                    row: cellId.match(/\d+/)[0]
                });
            }
            cell.contentEditable = false;
            cell.classList.remove('editing');
            state.editingCell = null;
            state.activeInput = null;
        }

        function setCellData(cellId, value, saveHistory = true) {
            state.data[cellId] = value;
            const cell = document.getElementById(`cell-${cellId}`);
            if (cell) {
                const indicator = cell.querySelector('.comment-indicator');
                cell.textContent = value;
                if (indicator) {
                    cell.appendChild(indicator);
                }
            }
        }

        function moveToNextCell() {
            if (!state.selectedCell) return;
            const match = state.selectedCell.match(/([A-Z]+)(\d+)/);
            const col = match[1];
            const row = parseInt(match[2]);
            const colIndex = state.colLetters.indexOf(col);
            let nextColIndex = colIndex + 1;
            while (nextColIndex < state.colLetters.length) {
                const nextCol = state.colLetters[nextColIndex];
                if (!CONFIG.readOnlyCol.includes(nextCol) && !isMetaCol(nextCol)) {
                    const nextCellId = `${nextCol}${row}`;
                    const nextCell = document.getElementById(`cell-${nextCellId}`);
                    if (nextCell && !nextCell.closest('tr').classList.contains('hidden-row')) {
                        selectCell(nextCellId);
                        startEdit(nextCellId);
                        return;
                    }
                }
                nextColIndex++;
            }
            const nextRow = row + 1;
            if (nextRow <= state.rows) {
                for (let i = 0; i < state.colLetters.length; i++) {
                    const c = state.colLetters[i];
                    if (!CONFIG.readOnlyCol.includes(c) && !isMetaCol(c)) {
                        const nextCellId = `${c}${nextRow}`;
                        const nextCell = document.getElementById(`cell-${nextCellId}`);
                        if (nextCell && !nextCell.closest('tr').classList.contains('hidden-row')) {
                            selectCell(nextCellId);
                            startEdit(nextCellId);
                            return;
                        }
                    }
                }
            }
        }

        function isDataCol(col) {
            return col >= 'A' && col <= 'T';
        }

        function isMetaCol(col) {
            const idx = state.colLetters.indexOf(col);
            return idx >= 20;
        }

        function getMetaCol(dataCol) {
            const index = dataCol.charCodeAt(0) - 'A'.charCodeAt(0);
            const metaIndex = index + 20;
            if (metaIndex < 26) {
                return String.fromCharCode(65 + metaIndex);
            } else {
                return 'A' + String.fromCharCode(65 + (metaIndex - 26));
            }
        }

        function syncMetaData(cellId) {
            const col = cellId.match(/[A-Z]+/)[0];
            if (!isDataCol(col) || CONFIG.noMetaCols.includes(col)) return;
            const row = cellId.match(/\d+/)[0];
            const metaCol = getMetaCol(col);
            const metaCellId = `${metaCol}${row}`;
            const cell = document.getElementById(`cell-${cellId}`);
            let color = '';
            if (cell.classList.contains('cell-yellow')) color = 'é»„è‰²';
            else if (cell.classList.contains('cell-red')) color = 'çº¢è‰²';
            else if (cell.classList.contains('cell-pink')) color = 'ç²‰è‰²';
            const comment = cell.dataset.comment || '';
            const metaValue = color + (comment ? CONFIG.metaDataSeparator + comment : '');
            setCellData(metaCellId, metaValue, false);
        }

        function calculateDColumn() {
            for (let r = 1; r <= state.rows; r++) {
                let count = 0;
                CONFIG.countColForD.forEach(col => {
                    const cellId = `${col}${r}`;
                    if (state.data[cellId] && state.data[cellId].trim() !== '') {
                        count++;
                    }
                });
                setCellData(`D${r}`, count.toString(), false);
            }
        }

        function checkDuplicates() {
            const excludeCols = ['C','D','E','F','G'];
            const valueMap = new Map();
            for (let r = 1; r <= state.rows; r++) {
                state.colLetters.forEach(col => {
                    if (!isDataCol(col) || excludeCols.includes(col)) return;
                    const cellId = `${col}${r}`;
                    const value = (state.data[cellId] || '').trim();
                    if (!value) return;
                    const num = parseFloat(value);
                    if (!isNaN(num) && num >= 0 && num <= 10) return;
                    if (!valueMap.has(value)) valueMap.set(value, []);
                    valueMap.get(value).push(cellId);
                });
            }
            document.querySelectorAll('.duplicate-cell').forEach(el => {
                el.classList.remove('duplicate-cell');
            });
            valueMap.forEach((cellIds, value) => {
                if (cellIds.length > 1) {
                    cellIds.forEach(id => {
                        const cell = document.getElementById(`cell-${id}`);
                        if (cell) cell.classList.add('duplicate-cell');
                    });
                }
            });
        }

        function formatCell(color) {
            const targets = state.selectedCells.size > 0 ? 
                Array.from(state.selectedCells) : 
                (state.selectedCell ? [state.selectedCell] : []);
            if (targets.length === 0) return;
            const changes = [];
            targets.forEach(cellId => {
                const col = cellId.match(/[A-Z]+/)[0];
                if (CONFIG.noMetaCols.includes(col)) return;
                const cell = document.getElementById(`cell-${cellId}`);
                const hadColor = cell.classList.contains('cell-yellow') || 
                                cell.classList.contains('cell-red') || 
                                cell.classList.contains('cell-pink');
                const oldColor = hadColor ? (cell.classList.contains('cell-yellow') ? 'é»„è‰²' : 
                                            cell.classList.contains('cell-red') ? 'çº¢è‰²' : 'ç²‰è‰²') : null;
                cell.classList.remove('cell-yellow', 'cell-red', 'cell-pink');
                if (color !== 'clear') {
                    cell.classList.add(`cell-${color}`);
                }
                if (isDataCol(col) && !CONFIG.noMetaCols.includes(col)) {
                    syncMetaData(cellId);
                }
                changes.push({ cellId, oldColor, newColor: color !== 'clear' ? color : null });
            });
            const actionType = targets.length > 1 ? ACTION_TYPES.FORMAT_MULTI : ACTION_TYPES.FORMAT_CELL;
            saveToHistory(actionType, { 
                color, 
                cellCount: targets.length,
                changes,
                firstCell: targets[0]
            });
        }

        function clearCellFormat() {
            formatCell('clear');
        }

        function addComment() {
            const cellId = state.selectedCell;
            if (!cellId) return;
            const col = cellId.match(/[A-Z]+/)[0];
            if (CONFIG.noMetaCols.includes(col)) {
                showToast('C-Gåˆ—ä¸æ”¯æŒå¤‡æ³¨åŠŸèƒ½');
                return;
            }
            const cell = document.getElementById(`cell-${cellId}`);
            const currentComment = cell.dataset.comment || '';
            const newComment = prompt('è¯·è¾“å…¥å¤‡æ³¨ï¼š', currentComment);
            if (newComment === null) return;
            const oldComment = currentComment;
            if (newComment.trim()) {
                cell.dataset.comment = newComment.trim();
                if (!cell.querySelector('.comment-indicator')) {
                    const indicator = document.createElement('div');
                    indicator.className = 'comment-indicator';
                    cell.appendChild(indicator);
                }
            } else {
                clearComment();
                return;
            }
            syncMetaData(cellId);
            saveToHistory(ACTION_TYPES.ADD_COMMENT, { cellId, oldComment, newComment: newComment.trim() });
        }

        function clearComment() {
            const cellId = state.selectedCell;
            if (!cellId) return;
            const col = cellId.match(/[A-Z]+/)[0];
            if (CONFIG.noMetaCols.includes(col)) return;
            const cell = document.getElementById(`cell-${cellId}`);
            const oldComment = cell.dataset.comment || '';
            delete cell.dataset.comment;
            const indicator = cell.querySelector('.comment-indicator');
            if (indicator) indicator.remove();
            syncMetaData(cellId);
            saveToHistory(ACTION_TYPES.CLEAR_COMMENT, { cellId, oldComment });
        }

        function showContextMenu(e, cellId) {
            e.preventDefault();
            selectCell(cellId);
            const menu = document.getElementById('contextMenu');
            let menuX = e.pageX;
            let menuY = e.pageY;
            const menuWidth = 261.36;
            const menuHeight = 420;
            if (menuX + menuWidth > window.innerWidth) {
                menuX = window.innerWidth - menuWidth - 10;
            }
            if (menuY + menuHeight > window.innerHeight) {
                menuY = window.innerHeight - menuHeight - 10;
            }
            if (menuY < 0) menuY = 10;
            menu.style.display = 'block';
            menu.style.left = menuX + 'px';
            menu.style.top = menuY + 'px';
        }

        function addNewRow() {
            const previousRows = state.rows;
            state.rows++;
            const tbody = document.getElementById('tableBody');
            const r = state.rows - 1;
            let html = `<tr data-row-num="${state.rows}"><th class="row-header" onclick="selectRow(${r})">${state.rows}</th>`;
            state.colLetters.forEach((col, idx) => {
                const isMeta = idx >= 20;
                const isReadOnly = CONFIG.readOnlyCol.includes(col);
                const cellId = `${col}${state.rows}`;
                const isFixed = CONFIG.noResizeCols.includes(col);
                const width = getColWidth(col, idx);
                const widthStyle = isFixed ? `width: ${width}px; min-width: ${width}px; max-width: ${width}px;` : `min-width: ${width}px;`;
                
                html += `
                    <td data-row="${r}" data-col="${col}" data-id="${cellId}" 
                        class="${isMeta ? 'meta-col' : ''} ${isReadOnly ? '' : 'editable'}"
                        style="${widthStyle}"
                        onclick="handleCellClick(event, '${cellId}')"
                        onmouseenter="highlightRow(${r}); showCommentTooltip(event, '${cellId}')"
                        onmouseleave="clearHighlight(); hideCommentTooltip()">
                        <div class="cell-content" id="cell-${cellId}"></div>
                    </td>
                `;
            });
            html += '</tr>';
            tbody.insertAdjacentHTML('beforeend', html);
            setCellData(`D${state.rows}`, '0', false);
            const container = document.getElementById('container');
            container.scrollTop = container.scrollHeight;
            saveToHistory(ACTION_TYPES.ADD_ROW, { rowNum: state.rows, previousRows });
            selectCell(`A${state.rows}`);
        }

        function deleteSelectedRow() {
            if (!state.selectedCell) return;
            const rowNum = parseInt(state.selectedCell.match(/\d+/)[0]);
            const deletedData = {};
            state.colLetters.forEach(col => {
                const cellId = `${col}${rowNum}`;
                deletedData[cellId] = state.data[cellId] || '';
            });
            state.colLetters.forEach(col => {
                const cellId = `${col}${rowNum}`;
                delete state.data[cellId];
            });
            for (let r = rowNum; r < state.rows; r++) {
                state.colLetters.forEach(col => {
                    const fromId = `${col}${r + 1}`;
                    const toId = `${col}${r}`;
                    state.data[toId] = state.data[fromId];
                    delete state.data[fromId];
                });
            }
            state.rows--;
            renderEmptyRows();
            Object.entries(state.data).forEach(([cellId, value]) => {
                const cell = document.getElementById(`cell-${cellId}`);
                if (cell) cell.textContent = value;
            });
            restoreStyles();
            calculateDColumn();
            checkDuplicates();
            clearAllSelections();
            saveToHistory(ACTION_TYPES.DELETE_ROW, { 
                rowNum, 
                deletedData,
                nextRow: rowNum <= state.rows ? rowNum : null
            });
            showToast(`å·²åˆ é™¤ç¬¬ ${rowNum} è¡Œ`);
        }

        function restoreStyles() {
            for (let r = 1; r <= state.rows; r++) {
                for (let c = 'A'; c <= 'T'; c = String.fromCharCode(c.charCodeAt(0) + 1)) {
                    if (CONFIG.noMetaCols.includes(c)) continue;
                    const metaCol = getMetaCol(c);
                    const metaCellId = `${metaCol}${r}`;
                    const metaValue = state.data[metaCellId] || '';
                    if (metaValue) {
                        const parts = metaValue.split(CONFIG.metaDataSeparator);
                        const color = parts[0];
                        const comment = parts[1];
                        const cellId = `${c}${r}`;
                        const cell = document.getElementById(`cell-${cellId}`);
                        if (!cell) continue;
                        if (color === 'é»„è‰²') cell.classList.add('cell-yellow');
                        else if (color === 'çº¢è‰²') cell.classList.add('cell-red');
                        else if (color === 'ç²‰è‰²') cell.classList.add('cell-pink');
                        if (comment) {
                            cell.dataset.comment = comment;
                            if (!cell.querySelector('.comment-indicator')) {
                                const indicator = document.createElement('div');
                                indicator.className = 'comment-indicator';
                                cell.appendChild(indicator);
                            }
                        }
                    }
                }
            }
        }

        function clearSelectedCells() {
            const targets = state.selectedCells.size > 0 ? 
                Array.from(state.selectedCells) : 
                (state.selectedCell ? [state.selectedCell] : []);
            if (targets.length === 0) return;
            const clearedData = [];
            targets.forEach(cellId => {
                const col = cellId.match(/[A-Z]+/)[0];
                const oldValue = state.data[cellId] || '';
                if (CONFIG.readOnlyCol.includes(col)) {
                    setCellData(cellId, '0', false);
                    clearedData.push({ cellId, oldValue, newValue: '0' });
                } else {
                    setCellData(cellId, '', false);
                    clearedData.push({ cellId, oldValue, newValue: '' });
                }
            });
            calculateDColumn();
            const actionType = targets.length > 1 ? ACTION_TYPES.CLEAR_MULTI : ACTION_TYPES.CLEAR_CONTENT;
            saveToHistory(actionType, { 
                cellCount: targets.length, 
                clearedData,
                firstCell: targets[0]
            });
        }

        function saveToHistory(actionType, actionData) {
            if (state.isUndoRedo) return;
            state.redoStack = [];
            if (state.historyStack.length >= CONFIG.maxHistory) {
                state.historyStack.shift();
            }
            const container = document.getElementById('container');
            const historyEntry = {
                data: JSON.parse(JSON.stringify(state.data)),
                headerData: JSON.parse(JSON.stringify(state.headerData)),
                rows: state.rows,
                isFilterActive: state.isFilterActive,
                searchTerm: state.searchTerm,
                filteredRows: Array.from(state.filteredRows),
                scrollPosition: { ...state.scrollPosition },
                selectedCell: state.selectedCell,
                actionType: actionType || 'æœªçŸ¥æ“ä½œ',
                actionData: actionData,
                timestamp: new Date().getTime()
            };
            state.historyStack.push(historyEntry);
            state.lastAction = actionType;
            updateUndoRedoButtons();
        }

        function undo() {
            if (state.historyStack.length <= 1) return;
            state.isUndoRedo = true;
            const currentState = state.historyStack.pop();
            state.redoStack.push(currentState);
            const previousState = state.historyStack[state.historyStack.length - 1];
            restoreState(previousState, true);
            state.isUndoRedo = false;
            updateUndoRedoButtons();
        }

        function redo() {
            if (state.redoStack.length === 0) return;
            state.isUndoRedo = true;
            const nextState = state.redoStack.pop();
            state.historyStack.push(nextState);
            restoreState(nextState, false);
            state.isUndoRedo = false;
            updateUndoRedoButtons();
        }

        function restoreState(savedState, isUndo) {
            state.data = JSON.parse(JSON.stringify(savedState.data));
            state.headerData = JSON.parse(JSON.stringify(savedState.headerData));
            state.rows = savedState.rows;
            state.isFilterActive = savedState.isFilterActive;
            state.searchTerm = savedState.searchTerm;
            state.filteredRows = new Set(savedState.filteredRows || []);
            state.scrollPosition = savedState.scrollPosition || { top: 0, left: 0 };
            const filterBtn = document.getElementById('filterToggle');
            const searchInput = document.getElementById('searchInput');
            if (state.isFilterActive) {
                filterBtn.classList.add('btn-active');
                filterBtn.textContent = 'æ˜¾ç¤ºå…¨éƒ¨';
            } else {
                filterBtn.classList.remove('btn-active');
                filterBtn.textContent = 'ç­›é€‰ï¼0';
            }
            searchInput.value = state.searchTerm || '';
            Object.entries(state.headerData).forEach(([col, value]) => {
                const th = document.querySelector(`th[data-col="${col}"] .header-text`);
                if (th) th.textContent = value;
            });
            renderEmptyRows();
            Object.entries(state.data).forEach(([cellId, value]) => {
                const cell = document.getElementById(`cell-${cellId}`);
                if (cell) cell.textContent = value;
            });
            restoreStyles();
            calculateDColumn();
            checkDuplicates();
            applyCombinedFilter();
            const container = document.getElementById('container');
            if (savedState.scrollPosition) {
                container.scrollTop = savedState.scrollPosition.top;
                container.scrollLeft = savedState.scrollPosition.left;
            }
            if (savedState.selectedCell) {
                const cell = document.getElementById(`cell-${savedState.selectedCell}`);
                if (cell && !cell.closest('tr').classList.contains('hidden-row')) {
                    selectCell(savedState.selectedCell);
                } else {
                    const rowNum = savedState.selectedCell.match(/\d+/)[0];
                    const row = document.querySelector(`tr[data-row-num="${rowNum}"]`);
                    if (row && !row.classList.contains('hidden-row')) {
                        const firstVisible = row.querySelector('td.editable');
                        if (firstVisible) {
                            selectCell(firstVisible.dataset.id);
                        }
                    }
                }
            }
            const actionType = savedState.actionType || 'æœªçŸ¥æ“ä½œ';
            const actionMsg = isUndo ? `â†©ï¸ å·²æ’¤é”€ï¼š${actionType}` : `â†ªï¸ å·²æ¢å¤ï¼š${actionType}`;
            showToast(actionMsg, isUndo ? 'undo' : 'redo');
        }

        function applyCombinedFilter() {
            document.querySelectorAll('.search-highlight').forEach(el => {
                el.classList.remove('search-highlight');
            });
            for (let r = 1; r <= state.rows; r++) {
                const row = document.querySelector(`tr[data-row-num="${r}"]`);
                if (!row) continue;
                let shouldHide = false;
                if (state.isFilterActive) {
                    const dVal = parseInt(state.data[`D${r}`] || '0');
                    if (dVal <= 0) {
                        shouldHide = true;
                    }
                }
                if (state.searchTerm && !shouldHide) {
                    if (!state.filteredRows.has(r)) {
                        shouldHide = true;
                    } else {
                        const aVal = (state.data[`A${r}`] || '').toLowerCase();
                        const bVal = (state.data[`B${r}`] || '').toLowerCase();
                        if (aVal.includes(state.searchTerm.toLowerCase())) {
                            const cellA = document.getElementById(`cell-A${r}`);
                            if (cellA) cellA.classList.add('search-highlight');
                        }
                        if (bVal.includes(state.searchTerm.toLowerCase())) {
                            const cellB = document.getElementById(`cell-B${r}`);
                            if (cellB) cellB.classList.add('search-highlight');
                        }
                    }
                }
                if (shouldHide) {
                    row.classList.add('hidden-row');
                } else {
                    row.classList.remove('hidden-row');
                }
            }
        }

        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            undoBtn.disabled = state.historyStack.length <= 1;
            redoBtn.disabled = state.redoStack.length === 0;
            if (state.historyStack.length > 1) {
                const lastAction = state.historyStack[state.historyStack.length - 1].actionType || 'ä¸Šä¸€æ­¥';
                undoBtn.title = `è¿”å›ä¸Šä¸€æ­¥ï¼š${lastAction}`;
            } else {
                undoBtn.title = 'æ²¡æœ‰å¯è¿”å›çš„æ“ä½œ';
            }
            if (state.redoStack.length > 0) {
                const nextAction = state.redoStack[state.redoStack.length - 1].actionType || 'ä¸‹ä¸€æ­¥';
                redoBtn.title = `æ¢å¤ä¸‹ä¸€æ­¥ï¼š${nextAction}`;
            } else {
                redoBtn.title = 'æ²¡æœ‰å¯æ¢å¤çš„æ“ä½œ';
            }
        }

        async function handleExcelImport(e) {
            const file = e.target.files[0];
            if (!file) return;
            if (state.editingCell) {
                endEdit();
            }
            const importState = {
                data: JSON.parse(JSON.stringify(state.data)),
                headerData: JSON.parse(JSON.stringify(state.headerData)),
                rows: state.rows,
                isFilterActive: state.isFilterActive,
                searchTerm: state.searchTerm,
                filteredRows: Array.from(state.filteredRows),
                scrollPosition: { ...state.scrollPosition }
            };
            state.data = {};
            state.headerData = {};
            state.selectedCell = null;
            state.selectedCells.clear();
            state.editingCell = null;
            state.activeInput = null;
            state.isFilterActive = false;
            state.searchTerm = '';
            state.filteredRows.clear();
            state.highlightedRow = null;
            state.historyStack = [];
            state.redoStack = [];
            state.isUndoRedo = false;
            state.scrollPosition = { top: 0, left: 0 };
            document.getElementById('searchInput').value = '';
            const filterBtn = document.getElementById('filterToggle');
            filterBtn.classList.remove('btn-active');
            filterBtn.textContent = 'ç­›é€‰ï¼0';
            updateUndoRedoButtons();
            document.querySelectorAll('.cell-content.selected').forEach(el => {
                el.classList.remove('selected');
            });
            document.querySelectorAll('tr.row-selected').forEach(tr => {
                tr.classList.remove('row-selected');
            });
            document.querySelectorAll('.search-highlight').forEach(el => {
                el.classList.remove('search-highlight');
            });
            document.querySelectorAll('tr.hidden-row').forEach(tr => {
                tr.classList.remove('hidden-row');
            });
            document.querySelectorAll('.row-highlight').forEach(el => {
                el.classList.remove('row-highlight');
            });
            document.getElementById('contextMenu').style.display = 'none';
            document.getElementById('commentPopup').classList.remove('show');
            document.getElementById('modalOverlay').classList.remove('show');
            showLoading('æ­£åœ¨å¯¼å…¥...');
            try {
                const data = await file.arrayBuffer();
                const workbook = XLSX.read(data, { type: 'array' });
                const sheet = workbook.Sheets[workbook.SheetNames[0]];
                const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
                if (jsonData.length > 0) {
                    const headers = jsonData[0];
                    headers.forEach((h, idx) => {
                        if (idx < state.colLetters.length && h) {
                            state.headerData[state.colLetters[idx]] = String(h);
                        }
                    });
                }
                const rows = jsonData.slice(1);
                state.rows = Math.max(rows.length, 100);
                renderEmptyRows();
                Object.entries(state.headerData).forEach(([col, value]) => {
                    const th = document.querySelector(`th[data-col="${col}"] .header-text`);
                    if (th) th.textContent = value;
                });
                rows.forEach((row, rIdx) => {
                    row.forEach((val, cIdx) => {
                        if (val !== undefined && val !== null && cIdx < state.colLetters.length) {
                            const col = state.colLetters[cIdx];
                            setCellData(`${col}${rIdx + 1}`, String(val), false);
                        }
                    });
                });
                calculateLHeader();
                calculateDColumn();
                checkDuplicates();
                // å¯¼å…¥åè‡ªåŠ¨è°ƒæ•´åˆ—å®½
                setTimeout(() => autoResizeColumns(), 100);
                
                // æ–°å¢ï¼šä¿å­˜å¹¶æ˜¾ç¤ºæ–‡ä»¶å
                state.lastImportFilename = file.name;
                const filenameDisplay = document.getElementById('importFilename');
                filenameDisplay.textContent = file.name;
                filenameDisplay.title = file.name;
                
                saveToHistory(ACTION_TYPES.IMPORT, { 
                    rowCount: rows.length,
                    previousState: importState,
                    fileName: file.name
                });
                saveToLocalStorage();
                hideLoading();
                showToast(`æˆåŠŸå¯¼å…¥ ${rows.length} è¡Œæ•°æ®`);
            } catch (err) {
                hideLoading();
                showToast('å¯¼å…¥å¤±è´¥: ' + err.message);
            }
            e.target.value = '';
        }

        function saveToExcel() {
            showLoading('æ­£åœ¨å¯¼å‡º...');
            try {
                const data = [];
                const header = state.colLetters.map(col => state.headerData[col] || col);
                data.push(header);
                for (let r = 1; r <= state.rows; r++) {
                    const row = [];
                    let hasData = false;
                    state.colLetters.forEach(col => {
                        const val = state.data[`${col}${r}`] || '';
                        row.push(val);
                        if (val) hasData = true;
                    });
                    if (hasData) data.push(row);
                }
                const ws = XLSX.utils.aoa_to_sheet(data);
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, 'è¯å“æ•°æ®');
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const filename = `ybæ•°æ®${year}${month}${day} ${hours}${minutes}.xlsx`;
                XLSX.writeFile(wb, filename);
                hideLoading();
                showToast('å¯¼å‡ºæˆåŠŸ');
            } catch (err) {
                hideLoading();
                showToast('å¯¼å‡ºå¤±è´¥: ' + err.message);
            }
        }

        function saveToLocalStorage() {
            try {
                const data = {
                    data: state.data,
                    headerData: state.headerData,
                    rows: state.rows,
                    lastImportFilename: state.lastImportFilename,
                    version: '2.6'
                };
                localStorage.setItem(CONFIG.storageKey, JSON.stringify(data));
            } catch (e) {
                console.error('ä¿å­˜å¤±è´¥:', e);
            }
        }

        function loadFromLocalStorage() {
            try {
                const saved = localStorage.getItem(CONFIG.storageKey);
                if (!saved) return false;
                const parsed = JSON.parse(saved);
                state.data = parsed.data || {};
                state.headerData = parsed.headerData || {};
                state.rows = parsed.rows || 100;
                // æ–°å¢ï¼šæ¢å¤æ–‡ä»¶åæ˜¾ç¤º
                if (parsed.lastImportFilename) {
                    state.lastImportFilename = parsed.lastImportFilename;
                    const filenameDisplay = document.getElementById('importFilename');
                    filenameDisplay.textContent = parsed.lastImportFilename;
                    filenameDisplay.title = parsed.lastImportFilename;
                }
                renderEmptyRows();
                Object.entries(state.headerData).forEach(([col, value]) => {
                    const th = document.querySelector(`th[data-col="${col}"] .header-text`);
                    if (th) th.textContent = value;
                });
                Object.entries(state.data).forEach(([cellId, value]) => {
                    const cell = document.getElementById(`cell-${cellId}`);
                    if (cell) cell.textContent = value;
                });
                calculateLHeader();
                calculateDColumn();
                checkDuplicates();
                restoreStyles();
                return true;
            } catch (e) {
                console.error('åŠ è½½å¤±è´¥:', e);
                return false;
            }
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function showLoading(text) {
            document.getElementById('loadingText').textContent = text;
            document.getElementById('loadingOverlay').style.display = 'flex';
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').style.display = 'none';
        }

        function showToast(msg, type = 'normal') {
            const toast = document.getElementById('toast');
            toast.textContent = msg;
            toast.className = 'toast show';
            if (type === 'undo') {
                toast.classList.add('undo-toast');
            } else if (type === 'redo') {
                toast.classList.add('redo-toast');
            }
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => {
                    toast.classList.remove('undo-toast', 'redo-toast');
                }, 300);
            }, 2500);
        }

        function initSampleData() {
            setCellData('A1', '6934114761936', false);
            setCellData('B1', 'btç”Ÿè„‰é¥®å…šå‚æ–¹ç›¾å…‹åº·ç¦', false);
            setCellData('C1', '62', false);
            setCellData('E1', '35', false);
            setCellData('J1', '240', false);
            setCellData('K1', '126.8', false);
            document.getElementById('cell-B1').classList.add('cell-yellow');
            document.getElementById('cell-C1').classList.add('cell-yellow');
            calculateDColumn();
        }

        function handleGlobalKeydown(e) {
            if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                undo();
            } else if (e.ctrlKey && e.key === 'y') {
                e.preventDefault();
                redo();
            } else if (e.key === 'Delete' && state.selectedCell && !state.editingCell) {
                e.preventDefault();
                clearSelectedCells();
            } else if (e.key === 'F2' && state.selectedCell && !state.editingCell) {
                e.preventDefault();
                startEdit(state.selectedCell);
            } else if (e.key === 'Enter' && state.editingCell) {
                e.preventDefault();
                endEdit();
                moveToNextCell();
            } else if (e.key === 'Escape' && state.editingCell) {
                e.preventDefault();
                const cell = document.getElementById(`cell-${state.editingCell}`);
                cell.textContent = state.data[state.editingCell] || '';
                endEdit();
            }
        }

        function closeCommentPopup() {
            document.getElementById('commentPopup').classList.remove('show');
            document.getElementById('modalOverlay').classList.remove('show');
        }

        // æ–°å¢ï¼šåŒå‡»åˆ—æ ‡é¢˜è‡ªåŠ¨è°ƒæ•´è¯¥åˆ—å®½åº¦
        function initColumnResizeEvents() {
            const headers = document.querySelectorAll('th.col-header');
            headers.forEach(th => {
                const col = th.dataset.col;
                if (CONFIG.noResizeCols.includes(col)) return; // è·³è¿‡C-Fåˆ—
                
                th.addEventListener('dblclick', (e) => {
                    if (e.target.classList.contains('header-text')) return; // åŒå‡»æ ‡é¢˜æ–‡å­—æ—¶ç¼–è¾‘
                    resizeSingleColumn(col);
                });
            });
        }
    </script>
</body>
</html>
