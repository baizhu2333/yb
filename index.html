<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>药品数据管理系统（优化版）</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: "Microsoft YaHei", Arial, sans-serif;
        }
        
        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            background-color: #f7fee7;
        }
        
        .container {
            width: 100%;
            height: 100%;
            padding: 15px;
            border: 1px solid #999;
            border-radius: 0;
            box-shadow: 0 4px 20px rgba(217, 249, 157, 0.3);
            background-color: #fefee8;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .toolbar {
            margin-bottom: 15px;
            display: flex;
            gap: 15px;
            align-items: center;
            padding: 15px 20px;
            background-color: #f7fee7;
            border-radius: 10px;
            border: 1px solid #999;
            flex-wrap: nowrap;
            min-height: 70px;
        }
        
        #searchInput {
            flex: 1;
            min-width: 350px;
            padding: 14px 18px;
            border: 1px solid #999;
            border-radius: 8px;
            font-size: 18px;
            background-color: white;
            transition: all 0.3s;
            pointer-events: auto;
            cursor: text;
        }
        
        #searchInput:focus {
            outline: none;
            border-color: #a3e635;
            box-shadow: 0 0 0 4px rgba(163, 230, 53, 0.3);
        }
        
        .toolbar button {
            padding: 14px 24px;
            background-color: #a3e635;
            color: #333;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            white-space: nowrap;
            font-size: 18px;
            min-height: 50px;
            letter-spacing: 0.5px;
        }
        
        .toolbar button:hover {
            background-color: #84cc16;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(132, 204, 22, 0.4);
        }
        
        .toolbar button:active {
            transform: translateY(0);
        }
        
        #filterToggle.active {
            background-color: #84cc16;
        }
        
        .btn-disabled {
            background-color: #e9fbb8 !important;
            cursor: not-allowed !important;
            transform: none !important;
            opacity: 0.6;
        }
        
        #saveBtn {
            background-color: #ff6b6b !important;
            color: white !important;
            border: 1px solid #ff5252 !important;
        }
        
        #saveBtn:hover {
            background-color: #ff5252 !important;
            box-shadow: 0 6px 12px rgba(255, 107, 107, 0.4) !important;
        }
        
        #importBtn {
            background-color: #ff8787 !important;
            color: white !important;
            border: 1px solid #ff6b6b !important;
        }
        
        #importBtn:hover {
            background-color: #ff6b6b !important;
            box-shadow: 0 6px 12px rgba(255, 135, 135, 0.4) !important;
        }
        
        #fileInput {
            display: none;
        }
        
        .table-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
            border-radius: 10px;
            border: 1px solid #999;
            background-color: white;
            position: relative;
        }
        
        .table-wrapper {
            flex: 1;
            overflow: auto;
            position: relative;
            width: 100%;
            height: 100%;
            scrollbar-width: thin;
            scrollbar-color: #a3e635 #f7fee7;
        }
        
        .table-wrapper::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }
        
        .table-wrapper::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .table-wrapper::-webkit-scrollbar-thumb {
            background-color: #a3e635;
            border-radius: 6px;
            border: 2px solid #999;
        }
        
        .table-wrapper::-webkit-scrollbar-corner {
            background-color: #999;
            border-radius: 0 0 6px 0;
        }
        
        .table-container {
            min-width: 100%;
            width: max-content;
            background-color: white;
            position: relative;
        }
        
        table {
            width: max-content;
            border-collapse: separate;
            border-spacing: 0;
            table-layout: fixed;
        }
        
        thead.sticky-header th {
            position: sticky;
            top: 0;
            z-index: 10;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        th.row-header {
            background-color: #e5f5d7 !important;
            color: #3f6212 !important;
            font-weight: bold;
            text-align: center;
            width: 36px !important;
            min-width: 36px !important;
            max-width: 36px !important;
            cursor: pointer;
            border-right: 1px solid #999 !important;
            position: sticky;
            left: 0;
            z-index: 11;
            padding: 3px 2px !important;
            font-size: 14px !important;
            height: 21px !important;
        }
        
        td.row-header {
            background-color: #f0f9e8 !important;
            color: #4d7c0f !important;
            font-weight: bold;
            text-align: center;
            width: 36px !important;
            min-width: 36px !important;
            max-width: 36px !important;
            cursor: pointer;
            border-right: 1px solid #999 !important;
            position: sticky;
            left: 0;
            z-index: 2;
            padding: 3px 2px !important;
            font-size: 14px !important;
            height: 21px !important;
        }
        
        tr.row-selected {
            background-color: rgba(224, 242, 254, 0.3) !important;
        }
        
        th {
            border: 1px solid #999 !important;
            padding: 3px 5px !important;
            text-align: left;
            min-width: 30px !important;
            max-width: 400px;
            background-color: #f7fee7;
            font-weight: bold;
            z-index: 2;
            line-height: 1.3;
            height: 21px !important;
            color: #4d7c0f;
            white-space: nowrap;
            font-size: 19px;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        th.meta-col {
            background-color: #e0e0e0 !important;
            color: #666 !important;
            font-size: 12px !important;
            width: 60px !important;
            min-width: 60px !important;
            max-width: 60px !important;
        }
        
        td.meta-col {
            background-color: #f5f5f5 !important;
            color: #999 !important;
            font-size: 10px !important;
            width: 60px !important;
            min-width: 60px !important;
            max-width: 60px !important;
            cursor: default !important;
        }
        
        .col-resize-handle {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 12px;
            height: 12px;
            border-radius: 3px;
            background-color: #a3e635;
            cursor: col-resize;
            z-index: 5;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        .col-resize-handle:hover {
            opacity: 1;
            background-color: #84cc16;
        }
        
        th[data-header="L"] {
            background-color: #f0f9e8;
        }
        
        td {
            border: 1px solid #999 !important;
            padding: 3px 5px !important;
            text-align: left !important;
            min-width: 30px !important;
            max-width: 400px;
            line-height: 1.3;
            height: 21px !important;
            cursor: text;
            position: relative;
            background-color: white;
            user-select: none;
            font-size: 18px;
            overflow: hidden !important;
            white-space: nowrap;
            text-overflow: ellipsis;
            word-wrap: break-word;
            word-break: break-all;
            color: #333 !important;
        }
        
        td[data-col="A"], th[data-header="A"] {
            width: 123px !important;
            min-width: 123px !important;
            max-width: 123px !important;
        }
        
        td[data-col="C"], th[data-header="C"],
        td[data-col="E"], th[data-header="E"] {
            width: 70px !important;
            min-width: 70px !important;
            max-width: 70px !important;
        }
        
        td[data-col="D"], td[data-col="F"],
        th[data-header="D"], th[data-header="F"] {
            width: 40px !important;
            min-width: 40px !important;
            max-width: 40px !important;
        }
        
        td[data-col="H"], td[data-col="I"], td[data-col="J"], td[data-col="K"],
        td[data-col="L"], td[data-col="M"], td[data-col="N"], td[data-col="O"],
        td[data-col="P"], td[data-col="Q"], td[data-col="R"], td[data-col="S"],
        td[data-col="T"], td[data-col="U"], td[data-col="V"], td[data-col="W"],
        td[data-col="X"], td[data-col="Y"], td[data-col="Z"],
        th[data-header="H"], th[data-header="I"], th[data-header="J"], th[data-header="K"],
        th[data-header="L"], th[data-header="M"], th[data-header="N"], th[data-header="O"],
        th[data-header="P"], th[data-header="Q"], th[data-header="R"], th[data-header="S"],
        th[data-header="T"], th[data-header="U"], th[data-header="V"], th[data-header="W"],
        th[data-header="X"], th[data-header="Y"], th[data-header="Z"] {
            width: 146px !important;
            min-width: 146px !important;
            max-width: 146px !important;
        }
        
        td[data-col="AA"], th[data-header="AA"],
        td[data-col="AB"], th[data-header="AB"],
        td[data-col="AC"], th[data-header="AC"],
        td[data-col="AD"], th[data-header="AD"],
        td[data-col="AE"], th[data-header="AE"],
        td[data-col="AF"], th[data-header="AF"],
        td[data-col="AG"], th[data-header="AG"],
        td[data-col="AH"], th[data-header="AH"],
        td[data-col="AI"], th[data-header="AI"],
        td[data-col="AJ"], th[data-header="AJ"],
        td[data-col="AK"], th[data-header="AK"],
        td[data-col="AL"], th[data-header="AL"],
        td[data-col="AM"], th[data-header="AM"],
        td[data-col="AN"], th[data-header="AN"] {
            width: 60px !important;
            min-width: 60px !important;
            max-width: 60px !important;
            background-color: #f9f9f9 !important;
            font-size: 10px !important;
            color: #666 !important;
        }
        
        .cell-content-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 18px;
            text-align: left !important;
            max-width: 100%;
            min-width: 0;
            flex-shrink: 1;
            padding: 0 !important;
            margin: 0 !important;
            padding-left: 2px !important;
            color: inherit !important;
        }
        
        td[data-col="A"] .cell-content-wrapper {
            font-size: 14px !important;
        }
        
        td[data-col="H"] .cell-content-wrapper, td[data-col="I"] .cell-content-wrapper,
        td[data-col="J"] .cell-content-wrapper, td[data-col="K"] .cell-content-wrapper,
        td[data-col="L"] .cell-content-wrapper, td[data-col="M"] .cell-content-wrapper,
        td[data-col="N"] .cell-content-wrapper, td[data-col="O"] .cell-content-wrapper,
        td[data-col="P"] .cell-content-wrapper, td[data-col="Q"] .cell-content-wrapper,
        td[data-col="R"] .cell-content-wrapper, td[data-col="S"] .cell-content-wrapper,
        td[data-col="T"] .cell-content-wrapper, td[data-col="U"] .cell-content-wrapper,
        td[data-col="V"] .cell-content-wrapper, td[data-col="W"] .cell-content-wrapper,
        td[data-col="X"] .cell-content-wrapper, td[data-col="Y"] .cell-content-wrapper,
        td[data-col="Z"] .cell-content-wrapper, td[data-col="AA"] .cell-content-wrapper,
        td[data-col="AB"] .cell-content-wrapper, td[data-col="AC"] .cell-content-wrapper,
        td[data-col="AD"] .cell-content-wrapper, td[data-col="AE"] .cell-content-wrapper,
        td[data-col="AF"] .cell-content-wrapper, td[data-col="AG"] .cell-content-wrapper,
        td[data-col="AH"] .cell-content-wrapper, td[data-col="AI"] .cell-content-wrapper,
        td[data-col="AJ"] .cell-content-wrapper, td[data-col="AK"] .cell-content-wrapper,
        td[data-col="AL"] .cell-content-wrapper, td[data-col="AM"] .cell-content-wrapper,
        td[data-col="AN"] .cell-content-wrapper {
            font-size: 10px !important;
        }
        
        td.editable {
            outline: none;
            user-select: text;
        }
        
        td.editable:focus {
            background-color: #f7fee7;
            outline: 3px solid #a3e635;
            outline-offset: -2px;
        }
        
        td[data-col="D"] {
            background-color: #fcfcec;
            color: #666;
            cursor: not-allowed;
            pointer-events: none;
            text-align: left !important;
        }
        
        .cell-yellow { 
            background-color: #fff200 !important; 
            border: 1px solid #999 !important;
        }
        .cell-red { 
            background-color: #ef5350 !important; 
            border: 1px solid #999 !important;
        }
        .cell-pink { 
            background-color: #f8bbd9 !important; 
            border: 1px solid #999 !important;
        }
        
        .duplicate-cell {
            background-color: #ef5350 !important;
            border: 1px solid #999 !important;
        }
        
        .header-cell {
            position: relative;
            text-align: left !important;
            overflow: hidden;
        }
        .header-cell input {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 3px 5px;
            border: 2px solid #999;
            border-radius: 4px;
            outline: none;
            background: white;
            font-weight: bold;
            font-size: 19px !important;
            color: #4d7c0f;
            text-align: left;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .header-cell.editing input {
            display: block;
        }
        .header-cell span {
            display: block;
            width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            text-align: left !important;
            padding-left: 2px;
        }
        .header-cell.editing span {
            display: none;
        }
        
        .header-link {
            color: #1976d2 !important;
            cursor: pointer !important;
            text-decoration: underline !important;
            text-align: left !important;
            font-size: 19px !important;
        }
        .header-link:hover {
            color: #1565c0 !important;
            background-color: #f7fee7 !important;
        }
        
        .cell-selected {
            background-color: #e0f2fe !important;
            border: 2px solid #38bdf8 !important;
        }
        .cell-drag-selected {
            background-color: #e0f2fe !important;
            border: 1px solid #38bdf8 !important;
        }
        
        td.row-col-highlight {
            background-color: #dcfce7 !important;
        }
        
        .selection-box {
            position: absolute;
            background-color: rgba(56, 189, 248, 0.1);
            border: 2px solid #38bdf8;
            pointer-events: none;
            z-index: 100;
        }
        
        .context-menu {
            position: absolute;
            width: 220px;
            background: white;
            border: 2px solid #999;
            border-radius: 8px;
            box-shadow: 0 6px 20px rgba(217, 249, 157, 0.4);
            z-index: 1000;
            display: none;
        }
        .context-menu-item {
            padding: 12px 16px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 17px;
        }
        .context-menu-item:hover {
            background-color: #f7fee7;
        }
        .context-menu-separator {
            height: 2px;
            background-color: #999;
            margin: 8px 0;
        }
        
        .search-highlight {
            background-color: #fef08a !important;
            border: 1px solid #999 !important;
        }
        
        .hidden {
            display: none !important;
        }
        
        .cell-comment-popup {
            position: absolute;
            background-color: #ffffe1;
            border: 1px solid #999;
            border-radius: 3px;
            padding: 8px 12px;
            font-size: 14px;
            max-width: 300px;
            min-width: 150px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
            z-index: 10000;
            display: none;
            word-wrap: break-word;
            white-space: normal;
            line-height: 1.4;
            color: #333;
            pointer-events: none;
        }
        
        .cell-comment-popup::before {
            content: '';
            position: absolute;
            top: -5px;
            left: 10px;
            width: 10px;
            height: 10px;
            background-color: #ffffe1;
            transform: rotate(45deg);
            border-left: 1px solid #999;
            border-top: 1px solid #999;
        }
        
        .comment-indicator {
            position: absolute;
            top: 1px;
            right: 1px;
            width: 6px;
            height: 6px;
            background-color: #ef5350;
            border-radius: 50%;
            z-index: 1;
            pointer-events: none;
        }
        
        .cell-input {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            outline: none;
            background: transparent;
            font-size: inherit;
            font-family: inherit;
            color: #333;
            padding: 3px 5px;
            margin: 0;
            z-index: 10;
            display: none;
            cursor: text;
            user-select: text;
            -webkit-user-select: text;
        }
        
        .cell-input.editing {
            display: block;
            background-color: white;
        }
        
        /* 加载指示器 */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255,255,255,0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            flex-direction: column;
            gap: 20px;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #a3e635;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-text {
            font-size: 18px;
            color: #333;
        }
        
        .progress-bar {
            width: 300px;
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: #a3e635;
            width: 0%;
            transition: width 0.3s;
        }
        
        /* 自动消失消息弹窗 - 居中 */
        .toast-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(51, 51, 51, 0.95);
            color: white;
            padding: 20px 40px;
            border-radius: 8px;
            font-size: 16px;
            z-index: 10001;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            max-width: 400px;
            text-align: center;
            line-height: 1.5;
        }
        
        .toast-message.show {
            display: block;
            animation: fadeIn 0.3s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
        <div class="loading-text" id="loadingText">正在处理...</div>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
    </div>

    <div class="toast-message" id="toastMessage"></div>

    <div class="container">
        <div class="toolbar">
            <input type="text" id="searchInput" placeholder="输入条码或药品名称，筛选A列或B列包含的内容...">
            <button id="clearSearchBtn">清空搜索</button>
            <button id="filterToggle">筛选＞0</button>
            <button id="addRowBtn">到最下方</button>
            <button id="importBtn">导入表格</button>
            <input type="file" id="fileInput" accept=".xlsx,.xlsm">
            <button id="saveBtn">保存表格</button>
            <button id="undoBtn" class="btn-disabled">撤销 (Ctrl+Z)</button>
            <button id="redoBtn" class="btn-disabled">恢复 (Ctrl+Y)</button>
        </div>

        <div class="table-section">
            <div class="table-wrapper" id="tableWrapper">
                <div class="table-container">
                    <table id="dataTable">
                        <thead class="sticky-header">
                            <tr id="tableHeaderRow"></tr>
                        </thead>
                        <tbody id="tableTbody"></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <div class="context-menu" id="cellContextMenu">
        <div class="context-menu-item" data-action="add-comment">添加备注</div>
        <div class="context-menu-item" data-action="clear-comment">清除备注</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" data-action="mark-red">标红</div>
        <div class="context-menu-item" data-action="mark-yellow">标黄</div>
        <div class="context-menu-item" data-action="mark-pink">标粉</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" data-action="clear-color">清除颜色</div>
    </div>

    <div class="cell-comment-popup" id="cellCommentPopup"></div>

    <script>
        // 全局配置
        const CONFIG = {
            maxCol: 'AN',
            dataMaxCol: 'T',
            metaDataStartCol: 'U',
            readOnlyCol: ['D'],
            calcHeaderCol: 'L',
            traceCodeCol: ['H','I','M','N'],
            countColForD: [],
            formulaHeaderCols: ['J', 'K'],
            storageKey: 'medicine_data_optimized_v1',
            metaDataSeparator: '|',
            batchSize: 50,
            renderDelay: 10,
            maxHistory: 20,
            debounceDelay: 300,
            importChunkSize: 100
        };
        
        for(let i='H'.charCodeAt(0); i<='T'.charCodeAt(0); i++) {
            CONFIG.countColForD.push(String.fromCharCode(i));
        }
        
        // 全局变量
        let isFilterActive = false;
        let originalData = [];
        let selectedCell = null;
        let selectedCells = new Set();
        let contextMenu = null;
        let commentPopup = null;
        let historyStack = [];
        let redoStack = [];
        let isUndoRedo = false;
        let colLetters = [];
        let isResizing = false;
        let resizeTh = null;
        let startX = 0;
        let startWidth = 0;
        let isDragging = false;
        let dragStartCell = null;
        let isCtrlPressed = false;
        let selectionBox = null;
        let dragStartX = 0;
        let dragStartY = 0;
        let lastSearchTerm = '';
        let autoSaveTimer = null;
        let isInitializing = true;
        let commentMouseEnterTimer = null;
        let commentMouseLeaveTimer = null;
        let activeInput = null;
        let isAtBottom = false;
        let isProcessing = false;
        let lastClickTime = 0;  // 用于双击检测

        // 防抖函数
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // 显示自动消失消息弹窗 - 修改为2秒自动消失，不响应点击
        let toastTimer = null;
        function showToast(message, duration = 2000) {
            const toast = document.getElementById('toastMessage');
            toast.textContent = message;
            toast.classList.add('show');
            
            if (toastTimer) clearTimeout(toastTimer);
            
            // 2秒后自动消失，不响应点击
            toastTimer = setTimeout(() => {
                hideToast();
            }, duration);
        }

        function hideToast() {
            const toast = document.getElementById('toastMessage');
            toast.classList.remove('show');
            if (toastTimer) {
                clearTimeout(toastTimer);
                toastTimer = null;
            }
        }

        function showLoading(text = '正在处理...') {
            document.getElementById('loadingText').textContent = text;
            document.getElementById('loadingOverlay').style.display = 'flex';
            document.getElementById('progressFill').style.width = '0%';
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').style.display = 'none';
        }

        function updateProgress(percent) {
            document.getElementById('progressFill').style.width = percent + '%';
        }

        // 页面初始化
        document.addEventListener('DOMContentLoaded', function() {
            contextMenu = document.getElementById('cellContextMenu');
            commentPopup = document.getElementById('cellCommentPopup');
            colLetters = generateColLetters(CONFIG.maxCol);
            initTableHeader();
            
            setTimeout(() => {
                if (!loadFromLocalStorage()) {
                    initSampleData();
                }
                initColResize();
                saveToHistory();
                initAllEvents();
                calcTargetHeader(CONFIG.calcHeaderCol);
                calculateDColumn();
                checkDuplicateCells();
                updateUndoRedoButtons();
                isInitializing = false;
            }, 100);
            
            window.addEventListener('beforeunload', function(e) {
                saveToLocalStorage();
            });
            
            let lastRightClickTime = 0;
            document.addEventListener('contextmenu', function(e) {
                const targetCell = e.target.closest('td.editable');
                if (!targetCell) return;
                
                const currentTime = new Date().getTime();
                const timeDiff = currentTime - lastRightClickTime;
                
                if (timeDiff < 300) {
                    e.preventDefault();
                    if (!selectedCells.has(targetCell)) { 
                        clearAllSelections(); 
                        selectCell(targetCell); 
                    }
                    contextMenu.style.display = 'block';
                    contextMenu.style.left = `${e.pageX}px`;
                    contextMenu.style.top = `${e.pageY}px`;
                    lastRightClickTime = 0;
                    return false;
                } else {
                    lastRightClickTime = currentTime;
                }
            }, true);
        });

        function generateColLetters(maxCol) {
            const letters = [];
            for (let i = 'A'.charCodeAt(0); i <= 'Z'.charCodeAt(0); i++) {
                letters.push(String.fromCharCode(i));
            }
            if (maxCol.length > 1 || maxCol > 'Z') {
                for (let i = 'A'.charCodeAt(0); i <= maxCol.charCodeAt(0); i++) {
                    for (let j = 'A'.charCodeAt(0); j <= 'Z'.charCodeAt(0); j++) {
                        const col = String.fromCharCode(i) + String.fromCharCode(j);
                        letters.push(col);
                        if (col === maxCol) return letters;
                    }
                }
            }
            return letters;
        }
        
        function getHeaderIndex(col) { return colLetters.indexOf(col); }
        function getHeaderCell(col) { return document.querySelector(`th[data-header="${col}"]`); }
        
        function getCellText(cell) {
            const wrapper = cell.querySelector('.cell-content-wrapper');
            return wrapper ? wrapper.textContent.trim() : '';
        }
        
        function setCellText(cell, text) {
            const wrapper = cell.querySelector('.cell-content-wrapper');
            if (wrapper) {
                wrapper.textContent = text;
                wrapper.style.paddingLeft = '2px';
            }
        }
        
        function isDataCol(col) {
            return col >= 'A' && col <= 'T';
        }
        
        function getMetaCol(dataCol) {
            const index = dataCol.charCodeAt(0) - 'A'.charCodeAt(0);
            const metaIndex = index + 20;
            if (metaIndex < 26) {
                return String.fromCharCode('A'.charCodeAt(0) + metaIndex);
            } else {
                const firstChar = 'A';
                const secondChar = String.fromCharCode('A'.charCodeAt(0) + (metaIndex - 26));
                return firstChar + secondChar;
            }
        }
        
        function getDataColFromMeta(metaCol) {
            let metaIndex;
            if (metaCol.length === 1) {
                metaIndex = metaCol.charCodeAt(0) - 'A'.charCodeAt(0);
            } else {
                metaIndex = 26 + (metaCol.charCodeAt(1) - 'A'.charCodeAt(0));
            }
            const dataIndex = metaIndex - 20;
            if (dataIndex >= 0 && dataIndex < 20) {
                return String.fromCharCode('A'.charCodeAt(0) + dataIndex);
            }
            return null;
        }

        const debouncedSync = debounce(() => {
            syncOriginalDataFromDOM();
        }, CONFIG.debounceDelay);

        function syncOriginalDataFromDOM() {
            if (isFilterActive) return;
            
            originalData = [];
            const rows = document.querySelectorAll('#dataTable tbody tr');
            rows.forEach((row, index) => {
                const rowData = {
                    rowNum: index + 1,
                    cells: {}
                };
                colLetters.forEach(col => {
                    const cell = row.querySelector(`td[data-col="${col}"]`);
                    if (cell) {
                        rowData.cells[col] = {
                            content: getCellText(cell),
                            classes: Array.from(cell.classList).filter(c => 
                                ['cell-yellow', 'cell-red', 'cell-pink', 'duplicate-cell', 'search-highlight'].includes(c)
                            ),
                            comment: cell.dataset.comment || '',
                            width: cell.style.width
                        };
                    }
                });
                originalData.push(rowData);
            });
        }

        function updateOriginalDataByRowNum(rowNum, rowElement) {
            const dataIndex = originalData.findIndex(d => d.rowNum === parseInt(rowNum));
            if (dataIndex === -1) {
                const newRowData = {
                    rowNum: parseInt(rowNum),
                    cells: {}
                };
                colLetters.forEach(col => {
                    const cell = rowElement.querySelector(`td[data-col="${col}"]`);
                    if (cell) {
                        newRowData.cells[col] = {
                            content: getCellText(cell),
                            classes: Array.from(cell.classList).filter(c => 
                                ['cell-yellow', 'cell-red', 'cell-pink', 'duplicate-cell', 'search-highlight'].includes(c)
                            ),
                            comment: cell.dataset.comment || '',
                            width: cell.style.width
                        };
                    }
                });
                originalData.push(newRowData);
            } else {
                colLetters.forEach(col => {
                    const cell = rowElement.querySelector(`td[data-col="${col}"]`);
                    if (cell) {
                        originalData[dataIndex].cells[col] = {
                            content: getCellText(cell),
                            classes: Array.from(cell.classList).filter(c => 
                                ['cell-yellow', 'cell-red', 'cell-pink', 'duplicate-cell', 'search-highlight'].includes(c)
                            ),
                            comment: cell.dataset.comment || '',
                            width: cell.style.width
                        };
                    }
                });
            }
        }

        function syncMetaData(dataCell) {
            const col = dataCell.dataset.col;
            if (!isDataCol(col)) return;
            
            const row = dataCell.parentElement;
            const rowNum = row.querySelector('.row-header').textContent;
            const metaCol = getMetaCol(col);
            const metaCell = row.querySelector(`td[data-col="${metaCol}"]`);
            if (!metaCell) return;
            
            let color = '';
            if (dataCell.classList.contains('cell-yellow')) color = '黄色';
            else if (dataCell.classList.contains('cell-red')) color = '红色';
            else if (dataCell.classList.contains('cell-pink')) color = '粉色';
            
            const comment = dataCell.dataset.comment || '';
            const metaValue = color + CONFIG.metaDataSeparator + comment;
            setCellText(metaCell, metaValue);
            metaCell.title = `元数据：${color ? '颜色=' + color : '无颜色'}${comment ? '，备注=' + comment : ''}`;
            
            updateOriginalDataByRowNum(parseInt(rowNum), row);
        }

        function restoreFromMetaData(row) {
            for (let i = 20; i < 40; i++) {
                let metaCol;
                if (i < 26) {
                    metaCol = String.fromCharCode('A'.charCodeAt(0) + i);
                } else {
                    metaCol = 'A' + String.fromCharCode('A'.charCodeAt(0) + (i - 26));
                }
                
                const metaCell = row.querySelector(`td[data-col="${metaCol}"]`);
                if (!metaCell) continue;
                
                const metaValue = getCellText(metaCell);
                if (!metaValue) continue;
                
                const parts = metaValue.split(CONFIG.metaDataSeparator);
                const color = parts[0] || '';
                const comment = parts[1] || '';
                
                const dataCol = getDataColFromMeta(metaCol);
                if (!dataCol) continue;
                
                const dataCell = row.querySelector(`td[data-col="${dataCol}"]`);
                if (!dataCell) continue;
                
                if (color) {
                    if (color === '黄色') setCellColor(dataCell, 'yellow');
                    else if (color === '红色') setCellColor(dataCell, 'red');
                    else if (color === '粉色') setCellColor(dataCell, 'pink');
                }
                
                if (comment) {
                    dataCell.dataset.comment = comment;
                    if (!dataCell.querySelector('.comment-indicator')) {
                        const indicator = document.createElement('div');
                        indicator.className = 'comment-indicator';
                        dataCell.appendChild(indicator);
                    }
                }
            }
        }

        function calculateFormula(formula) {
            if (!formula) return formula;
            const newFormula = formula.startsWith('--') ? '=' + formula.slice(2) : formula;
            if (!newFormula.startsWith('=')) return formula;
            try {
                const expr = newFormula.slice(1).replace(/[^0-9\+\-\*\/\.\(\)]/g, '');
                if (!expr) return formula;
                const result = Function(`'use strict'; return (${expr})`)();
                return isNaN(result) || !isFinite(result) ? formula : Number(result).toFixed(1);
            } catch (e) {
                return formula;
            }
        }

        function calcTargetHeader(targetCol) {
            const targetCell = getHeaderCell(targetCol);
            if (!targetCell) return;
            const targetIndex = getHeaderIndex(targetCol);
            const prev1Index = targetIndex - 1, prev2Index = targetIndex - 2;
            if (prev2Index < 0 || prev1Index < 0) {
                setCellText(targetCell, '列数不足');
                targetCell.querySelector('input').value = '列数不足';
                return;
            }
            const prev2Col = colLetters[prev2Index], prev1Col = colLetters[prev1Index];
            const prev2Val = parseFloat(getCellText(getHeaderCell(prev2Col))) || 0;
            const prev1Val = parseFloat(getCellText(getHeaderCell(prev1Col))) || 0;
            const result = (prev2Val - prev1Val).toFixed(1);
            setCellText(targetCell, result);
            targetCell.querySelector('input').value = result;
            calculateDColumn();
        }

        function initTableHeader() {
            const headerRow = document.getElementById('tableHeaderRow');
            const rowNumHeader = document.createElement('th');
            rowNumHeader.className = 'row-header';
            rowNumHeader.textContent = '#';
            rowNumHeader.style.width = '36px';
            headerRow.appendChild(rowNumHeader);
            
            const headerText = {
                A: '条码', B: '药品名称', C: '价', D: '无', E: 'hyj', F: '上限', G: '备注',
                H: 'Q02000000', I: '点击访问网站', J: '240', K: '126.8', L: '计算值',
                M: '', N: '', O: '', P: '', Q: '', R: '', S: '', T: '',
                U: 'A元', V: 'B元', W: 'C元', X: 'D元', Y: 'E元', Z: 'F元',
                AA: 'G元', AB: 'H元', AC: 'I元', AD: 'J元', AE: 'K元', AF: 'L元',
                AG: 'M元', AH: 'N元', AI: 'O元', AJ: 'P元', AK: 'Q元', AL: 'R元',
                AM: 'S元', AN: 'T元'
            };
            
            colLetters.forEach((col, index) => {
                const th = document.createElement('th');
                th.className = 'header-cell';
                th.dataset.header = col;
                
                if (index >= 20) th.classList.add('meta-col');
                
                if (col === 'A') {
                    th.style.width = '123px';
                    th.style.minWidth = '123px';
                } else if (col === 'C' || col === 'E') {
                    th.style.width = '70px';
                    th.style.minWidth = '70px';
                } else if (col === 'D' || col === 'F') {
                    th.style.width = '40px';
                    th.style.minWidth = '40px';
                } else if (index >= 7 && index <= 19) {
                    th.style.width = '146px';
                    th.style.minWidth = '146px';
                } else if (index >= 20) {
                    th.style.width = '60px';
                    th.style.minWidth = '60px';
                    th.style.maxWidth = '60px';
                } else {
                    th.style.width = '150px';
                    th.style.minWidth = '30px';
                }
                
                th.style.height = '21px';
                if (col === 'I') th.classList.add('header-link');
                if (col === CONFIG.calcHeaderCol) th.style.backgroundColor = '#f0f9e8';
                const text = headerText[col] || '';
                th.innerHTML = `<div class="cell-content-wrapper"><span>${text}</span></div><input type="text" value="${text}" data-header="${col}">`;
                
                if (index < 20) {
                    const resizeHandle = document.createElement('div');
                    resizeHandle.className = 'col-resize-handle';
                    th.appendChild(resizeHandle);
                }
                headerRow.appendChild(th);
            });
        }

        function initSampleData() {
            const tbody = document.getElementById('tableTbody');
            const row1 = createNewRow(1);
            setCellText(row1.querySelector('[data-col="A"]'), '6934114761936');
            setCellText(row1.querySelector('[data-col="B"]'), 'bt生脉饮党参方盾克康福');
            setCellText(row1.querySelector('[data-col="C"]'), '62');
            setCellText(row1.querySelector('[data-col="E"]'), '35');
            setCellText(row1.querySelector('[data-col="F"]'), 'bt');
            setCellText(row1.querySelector('[data-col="G"]'), '');
            setCellText(row1.querySelector('[data-col="H"]'), '84680850001502374758');
            setCellText(row1.querySelector('[data-col="J"]'), '240');
            setCellText(row1.querySelector('[data-col="K"]'), '126.8');
            setCellText(row1.querySelector('[data-col="L"]'), '113.2');
            
            row1.querySelector('[data-col="B"]').classList.add('cell-yellow');
            row1.querySelector('[data-col="C"]').classList.add('cell-yellow');
            
            syncMetaData(row1.querySelector('[data-col="B"]'));
            syncMetaData(row1.querySelector('[data-col="C"]'));
            
            tbody.appendChild(row1);
            
            const row2 = createNewRow(2);
            setCellText(row2.querySelector('[data-col="A"]'), '6975782860026');
            setCellText(row2.querySelector('[data-col="B"]'), 'ybx橡一活络油医用退热凝胶湖北5');
            setCellText(row2.querySelector('[data-col="C"]'), '59');
            setCellText(row2.querySelector('[data-col="E"]'), '50');
            setCellText(row2.querySelector('[data-col="F"]'), '');
            setCellText(row2.querySelector('[data-col="G"]'), '');
            setCellText(row2.querySelector('[data-col="H"]'), '0');
            tbody.appendChild(row2);
            
            syncOriginalDataFromDOM();
        }

        function createNewRow(rowNum) {
            const tr = document.createElement('tr');
            const rowNumCell = document.createElement('td');
            rowNumCell.className = 'row-header';
            rowNumCell.textContent = rowNum;
            rowNumCell.style.width = '36px';
            rowNumCell.style.height = '21px';
            tr.appendChild(rowNumCell);
            
            colLetters.forEach((col, index) => {
                const td = document.createElement('td');
                td.dataset.col = col;
                td.style.height = '21px';
                
                if (col === 'A') {
                    td.style.width = '123px';
                    td.style.minWidth = '123px';
                } else if (col === 'C' || col === 'E') {
                    td.style.width = '70px';
                    td.style.minWidth = '70px';
                } else if (col === 'D' || col === 'F') {
                    td.style.width = '40px';
                    td.style.minWidth = '40px';
                } else if (index >= 7 && index <= 19) {
                    td.style.width = '146px';
                    td.style.minWidth = '146px';
                } else if (index >= 20) {
                    td.style.width = '60px';
                    td.style.minWidth = '60px';
                    td.classList.add('meta-col');
                } else {
                    td.style.width = '150px';
                    td.style.minWidth = '30px';
                }
                
                const wrapper = document.createElement('div');
                wrapper.className = 'cell-content-wrapper';
                td.appendChild(wrapper);
                
                const input = document.createElement('input');
                input.className = 'cell-input';
                input.type = 'text';
                td.appendChild(input);
                
                if (index >= 20) {
                    td.classList.remove('editable');
                    input.disabled = true;
                } else if (CONFIG.readOnlyCol.includes(col)) {
                    td.classList.remove('editable');
                    setCellText(td, '0');
                    input.disabled = true;
                } else {
                    td.classList.add('editable');
                    if (CONFIG.traceCodeCol.includes(col)) td.classList.add('trace-code');
                    // 不再在这里绑定事件，改为事件委托
                }
                
                td.style.overflow = 'hidden';
                td.style.textAlign = 'left';
                td.style.paddingLeft = '5px';
                tr.appendChild(td);
            });
            return tr;
        }

        function initColResize() {
            document.querySelectorAll('.col-resize-handle').forEach(handle => {
                handle.addEventListener('mousedown', function(e) {
                    isResizing = true;
                    resizeTh = this.parentElement;
                    startX = e.clientX;
                    startWidth = resizeTh.offsetWidth;
                    document.body.style.cursor = 'col-resize';
                    e.preventDefault();
                    e.stopPropagation();
                    document.body.style.userSelect = 'none';
                    const overlay = document.createElement('div');
                    overlay.style.cssText = 'position: fixed;top:0;left:0;width:100%;height:100%;z-index:9999;cursor:col-resize;background:transparent;';
                    overlay.id = 'resize-overlay';
                    document.body.appendChild(overlay);
                });
            });
            
            document.addEventListener('mousemove', function(e) {
                if (!isResizing || !resizeTh) return;
                const newWidth = Math.max(20, startWidth + (e.clientX - startX));
                resizeTh.style.width = `${newWidth}px`;
                resizeTh.style.minWidth = `${newWidth}px`;
                const colIndex = Array.from(resizeTh.parentElement.children).indexOf(resizeTh);
                const dataCol = colLetters[colIndex - 1];
                document.querySelectorAll(`#dataTable tbody td[data-col="${dataCol}"]`).forEach(td => {
                    td.style.width = `${newWidth}px`;
                    td.style.minWidth = `${newWidth}px`;
                });
            });
            
            document.addEventListener('mouseup', function(e) {
                if (isResizing) {
                    const overlay = document.getElementById('resize-overlay');
                    overlay && overlay.remove();
                    isResizing = false;
                    resizeTh = null;
                    document.body.style.cursor = 'default';
                    document.body.style.userSelect = '';
                    !isUndoRedo && debouncedSync();
                    !isUndoRedo && saveToHistory();
                }
            });
        }

        // 【事件委托版】初始化所有事件
        function initAllEvents() {
            initSearchInput();
            initButtonEvents();
            initHeaderEditEvent();
            initContextMenuEvent();
            initKeyboardShortcut();
            initIHeaderLink();
            initDragSelection();
            initCommentPopup();
            initRowNumberClick();
            initCellEventsDelegation();  // 新增：单元格事件委托
            
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Control') isCtrlPressed = true;
            });
            document.addEventListener('keyup', function(e) {
                if (e.key === 'Control') isCtrlPressed = false;
            });
            
            document.addEventListener('click', function(e) {
                if (activeInput && !activeInput.parentElement.contains(e.target)) {
                    finishCellEdit(activeInput);
                }
                if (!e.target.closest('#dataTable')) {
                    clearRowColHighlight();
                }
            });
        }

        // 【新增】单元格事件委托 - 核心优化
        function initCellEventsDelegation() {
            const tbody = document.getElementById('tableTbody');
            
            // 单击和双击检测
            tbody.addEventListener('click', function(e) {
                const td = e.target.closest('td.editable');
                if (!td) return;
                
                const currentTime = new Date().getTime();
                const timeDiff = currentTime - lastClickTime;
                
                if (timeDiff < 300) {
                    // 双击
                    e.stopPropagation();
                    handleCellDblClick(td);
                } else {
                    // 单击（延迟执行以区分双击）
                    setTimeout(() => {
                        if (currentTime === lastClickTime) {
                            handleCellClick(td, e);
                        }
                    }, 300);
                }
                lastClickTime = currentTime;
            });
            
            // 输入框键盘事件委托
            tbody.addEventListener('keydown', function(e) {
                if (!e.target.classList.contains('cell-input')) return;
                
                const input = e.target;
                const td = input.parentElement;
                
                if (e.key === 'Enter') {
                    e.preventDefault();
                    finishCellEdit(input);
                    handleEnterKeyMove(td);
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    cancelCellEdit(input, getCellText(td));
                } else if (e.key === 'Tab') {
                    e.preventDefault();
                    finishCellEdit(input);
                    handleTabKeyMove(td, e.shiftKey);
                }
            });
            
            // 输入框失焦事件委托
            tbody.addEventListener('focusout', function(e) {
                if (e.target.classList.contains('cell-input')) {
                    finishCellEdit(e.target);
                }
            });
        }

        // 【新增】处理单元格单击
        function handleCellClick(td, e) {
            if (activeInput && activeInput.parentElement === td && activeInput.classList.contains('editing')) return;
            
            const input = td.querySelector('.cell-input');
            if (!input) return;
            
            if (e.ctrlKey) {
                toggleCellSelection(td);
            } else if (e.shiftKey && selectedCell) {
                selectCellRange(selectedCell, td);
            } else { 
                clearAllSelections(); 
                selectCell(td); 
                startCellEdit(td, input, false, e.clientX); 
            }
        }

        // 【新增】处理单元格双击
        function handleCellDblClick(td) {
            const input = td.querySelector('.cell-input');
            if (input) {
                startCellEdit(td, input, true);
            }
        }

        function hasCellColor(cell) {
            return cell.classList.contains('cell-yellow') || 
                   cell.classList.contains('cell-red') || 
                   cell.classList.contains('cell-pink') ||
                   cell.classList.contains('duplicate-cell') ||
                   cell.classList.contains('search-highlight') ||
                   cell.classList.contains('cell-selected');
        }

        function highlightRowCol(cell) {
            if (!cell || !cell.dataset.col) return;
            clearRowColHighlight();
            
            const row = cell.parentElement;
            const colIndex = cell.cellIndex;
            
            Array.from(row.children).forEach((td, idx) => {
                if (idx === 0) return;
                if (!hasCellColor(td)) td.classList.add('row-col-highlight');
            });
            
            const table = document.getElementById('dataTable');
            Array.from(table.rows).forEach((tr, ridx) => {
                if (ridx === 0) return;
                const td = tr.children[colIndex];
                if (td && td.dataset.col && !hasCellColor(td)) {
                    td.classList.add('row-col-highlight');
                }
            });
        }

        function clearRowColHighlight() {
            document.querySelectorAll('.row-col-highlight').forEach(el => {
                el.classList.remove('row-col-highlight');
            });
        }

        // 【已删除】bindCellEvents 函数 - 不再需要

        function startCellEdit(td, input, selectAll = true, clickX = null) {
            if (activeInput && activeInput !== input) {
                finishCellEdit(activeInput);
            }
            
            const value = getCellText(td);
            input.value = value;
            input.classList.add('editing');
            input.focus({preventScroll: true});
            
            if (selectAll) {
                setTimeout(() => input.select(), 10);
            } else if (clickX !== null && value.length > 0) {
                setTimeout(() => {
                    const rect = input.getBoundingClientRect();
                    const clickOffsetX = clickX - rect.left;
                    const ratio = Math.min(1, Math.max(0, clickOffsetX / rect.width));
                    const pos = Math.floor(value.length * ratio);
                    input.setSelectionRange(pos, pos);
                }, 10);
            } else {
                setTimeout(() => input.setSelectionRange(value.length, value.length), 10);
            }
            
            activeInput = input;
            selectCell(td);
        }

        function finishCellEdit(input) {
            if (!input || !input.classList.contains('editing')) return;
            
            const td = input.parentElement;
            const newValue = input.value;
            const oldValue = getCellText(td);
            const col = td.dataset.col;
            const row = td.parentElement;
            const rowNum = row.querySelector('.row-header').textContent;
            
            if (newValue !== oldValue) {
                setCellText(td, newValue);
                updateOriginalDataByRowNum(parseInt(rowNum), row);
                
                if (isDataCol(col)) syncMetaData(td);
                
                !isUndoRedo && saveToHistory();
                debouncedSync();
                checkDuplicateCells();
                calculateDColumn();
            }
            
            input.classList.remove('editing');
            if (activeInput === input) activeInput = null;
            if (td && document.activeElement === input) td.focus();
        }

        function cancelCellEdit(input, originalValue) {
            if (!input || !input.classList.contains('editing')) return;
            input.value = originalValue;
            input.classList.remove('editing');
            if (activeInput === input) activeInput = null;
        }

        function handleEnterKeyMove(cell) {
            const row = cell.parentElement;
            const rows = Array.from(document.querySelectorAll('#dataTable tbody tr:not(.hidden)'));
            const currentRowIdx = rows.indexOf(row);
            const cells = Array.from(row.querySelectorAll('td.editable'));
            const currentCellIdx = cells.indexOf(cell);
            if (currentRowIdx < rows.length - 1) {
                const nextCell = rows[currentRowIdx + 1].querySelectorAll('td.editable')[currentCellIdx];
                if (nextCell) {
                    selectCell(nextCell);
                    return;
                }
            }
            selectCell(cell);
        }

        function handleTabKeyMove(cell, shiftKey) {
            const row = cell.parentElement;
            const cells = Array.from(row.querySelectorAll('td.editable'));
            const currentCellIdx = cells.indexOf(cell);
            
            if (shiftKey) {
                if (currentCellIdx > 0) selectCell(cells[currentCellIdx - 1]);
            } else {
                if (currentCellIdx < cells.length - 1) selectCell(cells[currentCellIdx + 1]);
            }
        }

        function initRowNumberClick() {
            document.getElementById('dataTable').addEventListener('click', function(e) {
                const rowHeader = e.target.closest('.row-header');
                if (!rowHeader) return;
                const tr = rowHeader.parentElement;
                if (!tr || tr.tagName !== 'TR') return;
                
                e.preventDefault();
                e.stopPropagation();
                
                clearAllSelections();
                clearRowColHighlight();
                
                document.querySelectorAll('#dataTable tr.row-selected').forEach(r => {
                    r.classList.remove('row-selected');
                });
                
                tr.classList.add('row-selected');
                
                const editableCells = tr.querySelectorAll('td.editable');
                editableCells.forEach(cell => {
                    selectedCells.add(cell);
                    cell.classList.add('cell-selected');
                });
                
                if (editableCells.length > 0) {
                    selectedCell = editableCells[0];
                    selectedCell.style.outline = '3px solid #a3e635';
                    selectedCell.focus();
                    highlightRowCol(selectedCell);
                }
            });
        }

        function initCommentPopup() {
            document.addEventListener('mouseover', function(e) {
                const cell = e.target.closest('td[data-col]');
                if (cell && cell.dataset.comment) {
                    clearTimeout(commentMouseLeaveTimer);
                    commentMouseEnterTimer = setTimeout(() => {
                        showCellComment(cell, e.clientX, e.clientY);
                    }, 500);
                }
            });
            
            document.addEventListener('mouseout', function(e) {
                const cell = e.target.closest('td[data-col]');
                if (cell && cell.dataset.comment) {
                    clearTimeout(commentMouseEnterTimer);
                    commentMouseLeaveTimer = setTimeout(() => hideCellComment(), 300);
                }
            });
            
            commentPopup.addEventListener('mouseover', () => clearTimeout(commentMouseLeaveTimer));
            commentPopup.addEventListener('mouseout', () => {
                commentMouseLeaveTimer = setTimeout(() => hideCellComment(), 300);
            });
        }

        function showCellComment(cell, mouseX, mouseY) {
            const comment = cell.dataset.comment;
            if (!comment) return;
            
            commentPopup.textContent = comment;
            commentPopup.style.display = 'block';
            
            const popupWidth = commentPopup.offsetWidth;
            const popupHeight = commentPopup.offsetHeight;
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            let left = mouseX + 10;
            let top = mouseY + 10;
            
            if (left + popupWidth > windowWidth - 10) left = mouseX - popupWidth - 10;
            if (top + popupHeight > windowHeight - 10) top = mouseY - popupHeight - 10;
            
            commentPopup.style.left = left + 'px';
            commentPopup.style.top = top + 'px';
        }

        function hideCellComment() {
            commentPopup.style.display = 'none';
        }

        const debouncedSearch = debounce(() => performSearch(), CONFIG.debounceDelay);

        function initSearchInput() {
            const searchInput = document.getElementById('searchInput');
            
            searchInput.addEventListener('input', function() {
                const term = this.value.trim();
                if (term === '' && lastSearchTerm !== '') {
                    clearSearchHighlights();
                    if (isFilterActive) {
                        applyFilter();
                    } else {
                        renderAllRowsFromOriginalData();
                    }
                    lastSearchTerm = '';
                    !isUndoRedo && saveToHistory();
                } else if (term !== lastSearchTerm) {
                    debouncedSearch();
                }
            });
            
            searchInput.addEventListener('keydown', e => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    performSearch();
                }
            });
        }

        // 【恢复原版】快速渲染所有行 - 1000行以内一次性渲染
        function renderAllRowsFromOriginalData() {
            const tbody = document.getElementById('tableTbody');
            tbody.innerHTML = '';
            
            const totalRows = originalData.length;
            if (totalRows === 0) return;
            
            // 1000行以内直接一次性渲染（使用DocumentFragment优化）
            const fragment = document.createDocumentFragment();
            
            originalData.forEach((rowData) => {
                const row = createRowFromData(rowData);
                fragment.appendChild(row);
            });
            
            tbody.appendChild(fragment);
            calculateDColumn();
        }

        function createRowFromData(rowData) {
            const row = createNewRow(rowData.rowNum);
            
            colLetters.forEach(col => {
                const cell = row.querySelector(`td[data-col="${col}"]`);
                const cellData = rowData.cells[col];
                if (cell && cellData) {
                    setCellText(cell, cellData.content);
                    cellData.classes.forEach(cls => {
                        if (cls) cell.classList.add(cls);
                    });
                    if (cellData.comment) {
                        cell.dataset.comment = cellData.comment;
                        const indicator = document.createElement('div');
                        indicator.className = 'comment-indicator';
                        cell.appendChild(indicator);
                    }
                    if (cellData.width) {
                        cell.style.width = cellData.width;
                        cell.style.minWidth = cellData.width;
                    }
                }
            });
            
            return row;
        }

        function performSearch() {
            const term = document.getElementById('searchInput').value.trim();
            lastSearchTerm = term;
            
            if (!term) {
                clearSearchHighlights();
                if (isFilterActive) {
                    applyFilter();
                } else {
                    renderAllRowsFromOriginalData();
                }
                saveToHistory();
                return;
            }
            
            clearSearchHighlights();
            
            const tbody = document.getElementById('tableTbody');
            tbody.innerHTML = '';
            
            const termLower = term.toLowerCase();
            const fragment = document.createDocumentFragment();
            
            originalData.forEach((rowData) => {
                const aContent = (rowData.cells['A']?.content || '').toLowerCase();
                const bContent = (rowData.cells['B']?.content || '').toLowerCase();
                
                const match = aContent.includes(termLower) || bContent.includes(termLower);
                
                if (match) {
                    const row = createRowFromData(rowData);
                    
                    if (aContent.includes(termLower)) {
                        const aCell = row.querySelector('[data-col="A"]');
                        if (aCell) aCell.classList.add('search-highlight');
                    }
                    if (bContent.includes(termLower)) {
                        const bCell = row.querySelector('[data-col="B"]');
                        if (bCell) bCell.classList.add('search-highlight');
                    }
                    
                    fragment.appendChild(row);
                }
            });
            
            tbody.appendChild(fragment);
            
            !isUndoRedo && saveToHistory();
        }

        function clearSearchHighlights() {
            document.querySelectorAll('.search-highlight').forEach(cell => {
                cell.classList.remove('search-highlight');
            });
        }

        function initButtonEvents() {
            document.getElementById('clearSearchBtn').addEventListener('click', function() {
                document.getElementById('searchInput').value = '';
                clearSearchHighlights();
                lastSearchTerm = '';
                
                // 【修复】清空搜索后总是回到首页（显示所有原始数据）
                // 关闭筛选状态，回到原始数据视图
                if (isFilterActive) {
                    isFilterActive = false;
                    document.getElementById('filterToggle').classList.remove('active');
                }
                
                // 渲染所有原始数据（首页）
                renderAllRowsFromOriginalData();
                
                !isUndoRedo && saveToHistory();
            });
            
            document.getElementById('filterToggle').addEventListener('click', function() {
                isFilterActive = !isFilterActive;
                toggleDColumnFilter();
                this.classList.toggle('active', isFilterActive);
            });
            
            document.getElementById('addRowBtn').addEventListener('click', handleAddRowBtnClick);
            document.getElementById('fileInput').addEventListener('change', handleExcelImport);
            document.getElementById('importBtn').addEventListener('click', () => document.getElementById('fileInput').click());
            document.getElementById('saveBtn').addEventListener('click', saveToExcel);
            document.getElementById('undoBtn').addEventListener('click', undo);
            document.getElementById('redoBtn').addEventListener('click', redo);
        }

        function handleAddRowBtnClick() {
            const tbody = document.getElementById('tableTbody');
            const rows = tbody.querySelectorAll('tr:not(.hidden)');
            const btn = document.getElementById('addRowBtn');
            
            let isCurrentlyAtBottom = false;
            if (selectedCell) {
                const currentRow = selectedCell.parentElement;
                const lastRow = rows[rows.length - 1];
                if (currentRow === lastRow) {
                    const editableCells = currentRow.querySelectorAll('td.editable');
                    if (selectedCell === editableCells[editableCells.length - 1]) {
                        isCurrentlyAtBottom = true;
                    }
                }
            }
            
            if (!isAtBottom && !isCurrentlyAtBottom) {
                if (rows.length > 0) {
                    const lastRow = rows[rows.length - 1];
                    const editableCells = lastRow.querySelectorAll('td.editable');
                    if (editableCells.length > 0) {
                        const lastCell = editableCells[editableCells.length - 1];
                        const tableWrapper = document.querySelector('.table-wrapper');
                        tableWrapper.scrollTop = tableWrapper.scrollHeight;
                        selectCell(lastCell);
                        isAtBottom = true;
                        btn.textContent = '新增药品';
                        btn.style.backgroundColor = '#ff6b6b';
                        
                        setTimeout(() => {
                            if (isAtBottom) btn.style.backgroundColor = '';
                        }, 3000);
                    }
                }
            } else {
                addNewRow();
                isAtBottom = false;
                btn.textContent = '到最下方';
                btn.style.backgroundColor = '';
                
                setTimeout(() => {
                    const newRows = tbody.querySelectorAll('tr:not(.hidden)');
                    if (newRows.length > 0) {
                        const lastRow = newRows[newRows.length - 1];
                        const firstEditable = lastRow.querySelector('td.editable');
                        if (firstEditable) {
                            const tableWrapper = document.querySelector('.table-wrapper');
                            tableWrapper.scrollTop = tableWrapper.scrollHeight;
                            selectCell(firstEditable);
                        }
                    }
                }, 0);
            }
        }

        function initHeaderEditEvent() {
            document.querySelectorAll('.header-cell:not(.header-link)').forEach(cell => {
                const input = cell.querySelector('input');
                const col = cell.dataset.header;
                
                cell.addEventListener('click', function(e) {
                    e.stopPropagation();
                    cell.classList.add('editing');
                    input.value = getCellText(cell);
                    input.focus();
                    input.select();
                });
                
                const finishEdit = () => {
                    cell.classList.remove('editing');
                    const finalValue = CONFIG.formulaHeaderCols.includes(col) 
                        ? calculateFormula(input.value) 
                        : input.value;
                    if (getCellText(cell) !== finalValue) {
                        setCellText(cell, finalValue);
                        input.value = finalValue;
                        calcTargetHeader(CONFIG.calcHeaderCol);
                        !isUndoRedo && saveToHistory();
                    }
                };
                
                input.addEventListener('blur', finishEdit);
                input.addEventListener('keydown', e => {
                    if (e.key === 'Enter') { e.preventDefault(); finishEdit(); }
                });
                input.addEventListener('click', e => e.stopPropagation());
            });
        }

        function initDragSelection() {
            selectionBox = document.createElement('div');
            selectionBox.className = 'selection-box';
            selectionBox.style.display = 'none';
            document.querySelector('.table-wrapper').appendChild(selectionBox);
            
            document.addEventListener('keydown', e => isCtrlPressed = e.ctrlKey);
            document.addEventListener('keyup', e => isCtrlPressed = e.ctrlKey);
            
            // 使用事件委托处理拖拽选择
            const tbody = document.getElementById('tableTbody');
            tbody.addEventListener('mousedown', function(e) {
                const td = e.target.closest('td.editable');
                if (!td) return;
                
                if (isCtrlPressed && e.button === 0) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (!e.shiftKey) clearAllSelections();
                    isDragging = true;
                    dragStartCell = td;
                    dragStartX = e.clientX;
                    dragStartY = e.clientY;
                    const rect = td.getBoundingClientRect();
                    const tableRect = document.querySelector('.table-wrapper').getBoundingClientRect();
                    selectionBox.style.left = (rect.left - tableRect.left) + 'px';
                    selectionBox.style.top = (rect.top - tableRect.top) + 'px';
                    selectionBox.style.width = rect.width + 'px';
                    selectionBox.style.height = rect.height + 'px';
                    selectionBox.style.display = 'block';
                    if (!selectedCells.has(td)) {
                        selectedCells.add(td);
                        td.classList.add('cell-drag-selected');
                    }
                    document.body.style.cursor = 'crosshair';
                }
            });
            
            document.addEventListener('mousemove', function(e) {
                if (!isDragging || !dragStartCell) return;
                e.preventDefault();
                const tableWrapper = document.querySelector('.table-wrapper');
                const tableRect = tableWrapper.getBoundingClientRect();
                const startRect = dragStartCell.getBoundingClientRect();
                const left = Math.min(startRect.left, e.clientX);
                const top = Math.min(startRect.top, e.clientY);
                const right = Math.max(startRect.right, e.clientX);
                const bottom = Math.max(startRect.bottom, e.clientY);
                selectionBox.style.left = (left - tableRect.left) + 'px';
                selectionBox.style.top = (top - tableRect.top) + 'px';
                selectionBox.style.width = (right - left) + 'px';
                selectionBox.style.height = (bottom - top) + 'px';
                selectCellsInArea(left, top, right, bottom);
            });
            
            document.addEventListener('mouseup', function(e) {
                if (isDragging) {
                    isDragging = false;
                    selectionBox.style.display = 'none';
                    document.body.style.cursor = 'default';
                    updateDragSelectedCells();
                    !isUndoRedo && saveToHistory();
                    dragStartCell = null;
                }
            });
        }

        function selectCellsInArea(left, top, right, bottom) {
            document.querySelectorAll('.cell-drag-selected').forEach(cell => {
                if (!selectedCells.has(cell)) cell.classList.remove('cell-drag-selected');
            });
            document.querySelectorAll('#dataTable td.editable').forEach(td => {
                const rect = td.getBoundingClientRect();
                if (rect.right > left && rect.left < right && rect.bottom > top && rect.top < bottom) {
                    if (!selectedCells.has(td)) {
                        selectedCells.add(td);
                        td.classList.add('cell-drag-selected');
                    }
                } else if (!selectedCells.has(td)) {
                    td.classList.remove('cell-drag-selected');
                }
            });
        }

        function updateDragSelectedCells() {
            selectedCells.forEach(cell => {
                cell.classList.remove('cell-drag-selected');
                cell.classList.add('cell-selected');
            });
        }

        function initContextMenuEvent() {
            contextMenu.querySelectorAll('.context-menu-item').forEach(item => {
                item.addEventListener('click', function() {
                    if (!selectedCell && selectedCells.size === 0) return;
                    const action = this.dataset.action;
                    
                    let cellsToProcess = selectedCells.size > 0 ? Array.from(selectedCells) : (selectedCell ? [selectedCell] : []);
                    
                    const affectedRowNums = new Set();
                    cellsToProcess.forEach(cell => {
                        const row = cell.parentElement;
                        const rowNum = parseInt(row.querySelector('.row-header').textContent);
                        affectedRowNums.add(rowNum);
                    });
                    
                    cellsToProcess.forEach(cell => {
                        if (!cell || cell.tagName !== 'TD') return;
                        switch(action) {
                            case 'mark-red': setCellColor(cell, 'red'); syncMetaData(cell); break;
                            case 'mark-yellow': setCellColor(cell, 'yellow'); syncMetaData(cell); break;
                            case 'mark-pink': setCellColor(cell, 'pink'); syncMetaData(cell); break;
                            case 'add-comment': addCellComment(cell); syncMetaData(cell); break;
                            case 'clear-comment': clearCellComment(cell); syncMetaData(cell); break;
                            case 'clear-color': setCellColor(cell, 'clear'); syncMetaData(cell); break;
                        }
                    });
                    
                    if (['mark-red','mark-yellow','mark-pink','clear-color','add-comment','clear-comment'].includes(action)) {
                        !isUndoRedo && saveToHistory();
                    }
                    contextMenu.style.display = 'none';
                });
            });
            document.addEventListener('click', () => contextMenu.style.display = 'none');
        }

        function initIHeaderLink() {
            const iHeader = document.querySelector('.header-link');
            if (!iHeader) return;
            
            iHeader.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                const targetUrl = 'https://www.mashangfangxin.com/   ';
                window.open(targetUrl, '_blank', 'noopener,noreferrer');
            });
            
            iHeader.addEventListener('contextmenu', e => e.preventDefault());
        }

        function initKeyboardShortcut() {
            document.addEventListener('keydown', function(e) {
                const activeElement = document.activeElement;
                const isSearchBox = activeElement === document.getElementById('searchInput');
                const isCellInput = activeElement && activeElement.classList.contains('cell-input');
                
                if (isSearchBox || isCellInput) {
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        if (isCellInput) cancelCellEdit(activeElement, getCellText(activeElement.parentElement));
                    }
                    if (!(e.ctrlKey && (e.key === 'Home' || e.key === 'End'))) return;
                }
                
                if (e.ctrlKey && e.key === 'z') { e.preventDefault(); undo(); return; }
                if (e.ctrlKey && e.key === 'y') { e.preventDefault(); redo(); return; }
                if (e.ctrlKey && e.key === 'Delete') {
                    e.preventDefault();
                    const selectedRows = document.querySelectorAll('#dataTable tr.row-selected');
                    if (selectedRows.length === 1) {
                        deleteSelectedRow(selectedRows[0]);
                    } else if (selectedCell) {
                        deleteSelectedRow(selectedCell.parentElement);
                    }
                    return;
                }
                if ((e.key === 'Delete' || e.key === 'Backspace') && !e.ctrlKey && selectedCells.size > 0) {
                    e.preventDefault();
                    const selectedRows = document.querySelectorAll('#dataTable tr.row-selected');
                    if (selectedRows.length === 1) {
                        clearSelectedRow(selectedRows[0]);
                    } else {
                        clearSelectedCells();
                    }
                    return;
                }
                if (e.key === 'F2' && selectedCell && selectedCell.classList.contains('editable')) {
                    e.preventDefault();
                    const input = selectedCell.querySelector('.cell-input');
                    if (input) startCellEdit(selectedCell, input, true);
                    return;
                }
                
                if (selectedCell && selectedCell.tagName === 'TD' && !e.ctrlKey && !e.altKey && !e.shiftKey) {
                    const row = selectedCell.parentElement;
                    const rows = Array.from(document.querySelectorAll('#dataTable tbody tr:not(.hidden)'));
                    const currentRowIndex = rows.indexOf(row);
                    const cells = Array.from(row.querySelectorAll('td.editable'));
                    const currentCellIndex = cells.indexOf(selectedCell);
                    
                    switch(e.key) {
                        case 'ArrowUp':
                            e.preventDefault();
                            if (currentRowIndex > 0) {
                                const targetCell = rows[currentRowIndex-1].querySelectorAll('td.editable')[currentCellIndex];
                                targetCell && selectCell(targetCell);
                            }
                            break;
                        case 'ArrowDown':
                            e.preventDefault();
                            if (currentRowIndex < rows.length-1) {
                                const targetCell = rows[currentRowIndex+1].querySelectorAll('td.editable')[currentCellIndex];
                                targetCell && selectCell(targetCell);
                            }
                            break;
                        case 'ArrowLeft':
                            e.preventDefault();
                            currentCellIndex > 0 && selectCell(cells[currentCellIndex-1]);
                            break;
                        case 'ArrowRight':
                            e.preventDefault();
                            currentCellIndex < cells.length-1 && selectCell(cells[currentCellIndex+1]);
                            break;
                    }
                }
            });
        }

        function deleteSelectedRow(row) {
            if (!row || row.tagName !== 'TR') return;
            
            const rowNum = parseInt(row.querySelector('.row-header').textContent);
            const dataIndex = originalData.findIndex(d => d.rowNum === rowNum);
            if (dataIndex !== -1) originalData.splice(dataIndex, 1);
            
            row.remove();
            
            const remainingRows = document.querySelectorAll('#dataTable tbody tr');
            remainingRows.forEach((r, index) => {
                const numCell = r.querySelector('.row-header');
                if (numCell) numCell.textContent = index + 1;
            });
            
            originalData.forEach((d, index) => d.rowNum = index + 1);
            
            clearAllSelections();
            clearRowColHighlight();
            selectedCell = null;
            selectedCells.clear();
            
            isAtBottom = false;
            const btn = document.getElementById('addRowBtn');
            btn.textContent = '到最下方';
            btn.style.backgroundColor = '';
            
            calculateDColumn();
            checkDuplicateCells();
            !isUndoRedo && saveToHistory();
        }

        function clearSelectedRow(row) {
            if (!row || row.tagName !== 'TR') return;
            
            const rowNum = parseInt(row.querySelector('.row-header').textContent);
            const dataIndex = originalData.findIndex(d => d.rowNum === rowNum);
            
            const allCells = row.querySelectorAll('td[data-col]');
            allCells.forEach(cell => {
                const col = cell.dataset.col;
                if (CONFIG.readOnlyCol.includes(col)) {
                    setCellText(cell, '0');
                } else {
                    setCellText(cell, '');
                }
                cell.classList.remove('cell-red', 'cell-yellow', 'cell-pink', 'duplicate-cell', 'search-highlight');
                clearCellComment(cell);
                
                if (dataIndex !== -1 && originalData[dataIndex].cells[col]) {
                    originalData[dataIndex].cells[col].content = CONFIG.readOnlyCol.includes(col) ? '0' : '';
                    originalData[dataIndex].cells[col].classes = [];
                    originalData[dataIndex].cells[col].comment = '';
                }
            });
            
            row.classList.remove('row-selected');
            clearAllSelections();
            clearRowColHighlight();
            
            for (let col = 'A'; col <= 'T'; col = String.fromCharCode(col.charCodeAt(0) + 1)) {
                const cell = row.querySelector(`td[data-col="${col}"]`);
                if (cell) syncMetaData(cell);
            }
            
            !isUndoRedo && saveToHistory();
            calculateDColumn();
            checkDuplicateCells();
        }

        function clearSelectedCells() {
            if (selectedCells.size === 0) return;
            const editableCells = Array.from(selectedCells).filter(cell => 
                cell.classList.contains('editable') && !cell.classList.contains('row-header')
            );
            if (editableCells.length === 0) return;
            
            const affectedRowNums = new Set();
            
            editableCells.forEach(cell => {
                const row = cell.parentElement;
                const rowNum = parseInt(row.querySelector('.row-header').textContent);
                affectedRowNums.add(rowNum);
                
                setCellText(cell, '');
                
                const dataIndex = originalData.findIndex(d => d.rowNum === rowNum);
                if (dataIndex !== -1 && originalData[dataIndex].cells[cell.dataset.col]) {
                    originalData[dataIndex].cells[cell.dataset.col].content = '';
                }
            });
            
            !isUndoRedo && saveToHistory();
            checkDuplicateCells();
            calculateDColumn();
            
            affectedRowNums.forEach(rowNum => {
                const rowIndex = originalData.findIndex(d => d.rowNum === rowNum);
                if (rowIndex !== -1) {
                    for (let col = 'A'; col <= 'T'; col = String.fromCharCode(col.charCodeAt(0) + 1)) {
                        const row = document.querySelector(`#dataTable tbody tr:nth-child(${rowIndex + 1})`);
                        if (row) {
                            const cell = row.querySelector(`td[data-col="${col}"]`);
                            if (cell) syncMetaData(cell);
                        }
                    }
                }
            });
        }

        function selectCell(cell) {
            clearRowColHighlight();
            
            document.querySelectorAll('#dataTable tr.row-selected').forEach(r => {
                r.classList.remove('row-selected');
            });
            clearAllSelections();
            selectedCell = cell;
            if (cell.tagName === 'TD') {
                cell.style.outline = '3px solid #a3e635';
                cell.classList.add('cell-selected');
                selectedCells.add(cell);
                cell.focus();
                highlightRowCol(cell);
            }
        }

        function clearAllSelections() {
            selectedCells.forEach(cell => {
                cell.classList.remove('cell-selected');
                cell.style.outline = '';
            });
            selectedCells.clear();
            selectedCell = null;
        }

        function toggleCellSelection(cell) {
            if (selectedCells.has(cell)) {
                selectedCells.delete(cell);
                cell.classList.remove('cell-selected');
                if (selectedCell === cell) selectedCell = selectedCells.size > 0 ? Array.from(selectedCells).pop() : null;
            } else {
                selectedCells.add(cell);
                cell.classList.add('cell-selected');
                selectedCell = cell;
            }
            if (selectedCell) selectedCell.style.outline = '3px solid #a3e635';
        }

        function selectCellRange(startCell, endCell) {
            clearAllSelections();
            clearRowColHighlight();
            
            const startRow = startCell.parentElement, endRow = endCell.parentElement;
            const rows = Array.from(document.querySelectorAll('#dataTable tbody tr:not(.hidden)'));
            const startRowIdx = rows.indexOf(startRow), endRowIdx = rows.indexOf(endRow);
            const startColIdx = getHeaderIndex(startCell.dataset.col), endColIdx = getHeaderIndex(endCell.dataset.col);
            const minRow = Math.min(startRowIdx, endRowIdx), maxRow = Math.max(startRowIdx, endRowIdx);
            const minCol = Math.min(startColIdx, endColIdx), maxCol = Math.max(startColIdx, endColIdx);
            
            for (let i = minRow; i <= maxRow; i++) {
                const row = rows[i];
                const cells = row.querySelectorAll('td.editable');
                for (let j = minCol; j <= maxCol; j++) {
                    const cell = cells[j];
                    if (cell) {
                        selectedCells.add(cell);
                        cell.classList.add('cell-selected');
                    }
                }
            }
            selectedCell = endCell;
            selectedCell.style.outline = '3px solid #a3e635';
            highlightRowCol(endCell);
        }

        function addNewRow() {
            const tbody = document.getElementById('tableTbody');
            const newRowNum = originalData.length + 1;
            const newRow = createNewRow(newRowNum);
            tbody.appendChild(newRow);
            
            const newRowData = {
                rowNum: newRowNum,
                cells: {}
            };
            colLetters.forEach(col => {
                newRowData.cells[col] = {
                    content: CONFIG.readOnlyCol.includes(col) ? '0' : '',
                    classes: [],
                    comment: '',
                    width: ''
                };
            });
            originalData.push(newRowData);
            
            if (isFilterActive) applyFilter();
            
            selectCell(newRow.querySelector('td.editable'));
            calculateDColumn();
            checkDuplicateCells();
            !isUndoRedo && saveToHistory();
            
            setTimeout(() => {
                const tableWrapper = document.querySelector('.table-wrapper');
                tableWrapper.scrollTop = tableWrapper.scrollHeight;
            }, 0);
        }

        function applyFilter() {
            const tbody = document.getElementById('tableTbody');
            tbody.innerHTML = '';
            
            const filtered = originalData.filter(rowData => {
                const dContent = rowData.cells['D']?.content || '0';
                const dVal = parseFloat(dContent) || 0;
                return dVal > 0;
            }).sort((a, b) => {
                const aVal = parseFloat(a.cells['C']?.content) || 0;
                const bVal = parseFloat(b.cells['C']?.content) || 0;
                return bVal - aVal;
            });
            
            const fragment = document.createDocumentFragment();
            
            filtered.forEach((rowData, index) => {
                const row = createRowFromData(rowData);
                const rowNumCell = row.querySelector('.row-header');
                if (rowNumCell) rowNumCell.textContent = index + 1;
                fragment.appendChild(row);
            });
            
            tbody.appendChild(fragment);
        }

        function toggleDColumnFilter() {
            if (isFilterActive) {
                applyFilter();
            } else {
                renderAllRowsFromOriginalData();
            }
            !isUndoRedo && saveToHistory();
        }

        function calculateDColumn() {
            document.querySelectorAll('#dataTable tbody tr').forEach(row => {
                const dCell = row.querySelector('[data-col="D"]');
                if (!dCell) return;
                let count = 0;
                CONFIG.countColForD.forEach(col => {
                    const cell = row.querySelector(`[data-col="${col}"]`);
                    if (getCellText(cell) !== '') count++;
                });
                setCellText(dCell, count.toString());
                
                const rowNum = parseInt(row.querySelector('.row-header').textContent);
                const dataIndex = originalData.findIndex(d => d.rowNum === rowNum);
                if (dataIndex !== -1) {
                    originalData[dataIndex].cells['D'].content = count.toString();
                }
            });
        }

        function checkDuplicateCells() {
            const excludeCols = ['C','D','E','F','G'];
            const valueMap = new Map();
            
            originalData.forEach((rowData, rowIndex) => {
                Object.keys(rowData.cells).forEach(col => {
                    if (excludeCols.includes(col)) return;
                    const cellData = rowData.cells[col];
                    const text = (cellData?.content || '').trim();
                    if (!text) return;
                    const numValue = parseFloat(text);
                    if (!isNaN(numValue) && numValue >= 0 && numValue <= 10) return;
                    if (!valueMap.has(text)) valueMap.set(text, []);
                    valueMap.get(text).push({rowIndex, col});
                });
            });
            
            document.querySelectorAll('.duplicate-cell').forEach(cell => cell.classList.remove('duplicate-cell'));
            originalData.forEach(rowData => {
                Object.keys(rowData.cells).forEach(col => {
                    if (rowData.cells[col].classes) {
                        rowData.cells[col].classes = rowData.cells[col].classes.filter(c => c !== 'duplicate-cell');
                    }
                });
            });
            
            valueMap.forEach((positions, val) => {
                if (positions.length > 1) {
                    positions.forEach(({rowIndex, col}) => {
                        const row = document.querySelectorAll('#dataTable tbody tr')[rowIndex];
                        if (row) {
                            const cell = row.querySelector(`td[data-col="${col}"]`);
                            if (cell) cell.classList.add('duplicate-cell');
                        }
                        if (originalData[rowIndex] && originalData[rowIndex].cells[col]) {
                            if (!originalData[rowIndex].cells[col].classes.includes('duplicate-cell')) {
                                originalData[rowIndex].cells[col].classes.push('duplicate-cell');
                            }
                        }
                    });
                }
            });
        }

        function addCellComment(cell) {
            clearCellComment(cell);
            const comment = prompt('请输入备注：', cell.dataset.comment || '');
            if (comment === null || comment.trim() === '') return;
            cell.dataset.comment = comment.trim();
            
            const existingIndicator = cell.querySelector('.comment-indicator');
            if (!existingIndicator) {
                const indicator = document.createElement('div');
                indicator.className = 'comment-indicator';
                cell.appendChild(indicator);
            }
            
            const rowNum = parseInt(cell.parentElement.querySelector('.row-header').textContent);
            updateOriginalDataByRowNum(rowNum, cell.parentElement);
        }

        function clearCellComment(cell) {
            delete cell.dataset.comment;
            const indicator = cell.querySelector('.comment-indicator');
            if (indicator) cell.removeChild(indicator);
            
            const rowNum = parseInt(cell.parentElement.querySelector('.row-header').textContent);
            updateOriginalDataByRowNum(rowNum, cell.parentElement);
        }

        function setCellColor(cell, color) {
            cell.classList.remove('cell-red', 'cell-yellow', 'cell-pink');
            if (color !== 'clear') cell.classList.add(`cell-${color}`);
            
            if (cell.classList.contains('row-col-highlight') && hasCellColor(cell)) {
                cell.classList.remove('row-col-highlight');
            }
            
            const rowNum = parseInt(cell.parentElement.querySelector('.row-header').textContent);
            const dataIndex = originalData.findIndex(d => d.rowNum === rowNum);
            if (dataIndex !== -1 && originalData[dataIndex].cells[cell.dataset.col]) {
                originalData[dataIndex].cells[cell.dataset.col].classes = Array.from(cell.classList).filter(c => 
                    ['cell-yellow', 'cell-red', 'cell-pink', 'duplicate-cell', 'search-highlight'].includes(c)
                );
            }
        }

        // 【优化版】Excel导入 - 移除数字序列检测逻辑
        async function handleExcelImport(e) {
            if (isProcessing) return;
            isProcessing = true;
            
            const file = e.target.files[0];
            if (!file || !['xlsx','xlsm'].includes(file.name.split('.').pop().toLowerCase())) {
                showToast('仅支持.xlsx/.xlsm格式！');
                e.target.value = '';
                isProcessing = false;
                return;
            }
            
            showLoading('正在读取文件...');
            
            await new Promise(resolve => setTimeout(resolve, 100));
            
            try {
                const arrayBuffer = await readFileAsync(file);
                
                showLoading('正在解析数据...');
                await new Promise(resolve => setTimeout(resolve, 50));
                
                const wb = await parseExcelAsync(arrayBuffer);
                const sheet = wb.Sheets[wb.SheetNames[0]];
                const range = XLSX.utils.decode_range(sheet['!ref'] || 'A1');
                const totalRows = range.e.r - range.s.r;
                
                showLoading(`正在处理 ${totalRows} 行数据...`);
                
                const data = [];
                const chunkSize = CONFIG.importChunkSize;
                
                for (let i = range.s.r; i <= range.e.r; i += chunkSize) {
                    const endRow = Math.min(i + chunkSize - 1, range.e.r);
                    const chunkRange = {
                        s: { r: i, c: range.s.c },
                        e: { r: endRow, c: range.e.c }
                    };
                    sheet['!ref'] = XLSX.utils.encode_range(chunkRange);
                    
                    const chunkData = XLSX.utils.sheet_to_json(sheet, { header: 1, raw: false });
                    data.push(...chunkData);
                    
                    updateProgress(Math.min(100, (endRow - range.s.r + 1) / (totalRows + 1) * 50));
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
                
                if (data.length <= 1) { 
                    showToast('无有效数据！');
                    hideLoading();
                    isProcessing = false;
                    return; 
                }
                
                const tbody = document.getElementById('tableTbody');
                tbody.innerHTML = '';
                originalData = [];
                
                const rowsData = data.slice(1);
                const importTotalRows = rowsData.length;
                
                for (let i = 0; i < importTotalRows; i += CONFIG.batchSize) {
                    const batch = rowsData.slice(i, i + CONFIG.batchSize);
                    
                    batch.forEach((rowData, batchIndex) => {
                        const rowIndex = i + batchIndex;
                        const newRow = createNewRow(rowIndex + 1);
                        const rowDataObj = {
                            rowNum: rowIndex + 1,
                            cells: {}
                        };
                        
                        // 直接按列索引对应，不进行数字序列检测
                        colLetters.forEach((col, colIndex) => {
                            const cell = newRow.querySelector(`td[data-col="${col}"]`);
                            const val = rowData[colIndex];
                            
                            rowDataObj.cells[col] = {
                                content: val !== undefined && val !== null ? String(val).trim() : '',
                                classes: [],
                                comment: '',
                                width: ''
                            };
                            
                            if (cell && val !== undefined && val !== null) {
                                setCellText(cell, String(val).trim());
                            }
                        });
                        
                        tbody.appendChild(newRow);
                        restoreFromMetaData(newRow);
                        
                        for (let col = 'A'; col <= 'T'; col = String.fromCharCode(col.charCodeAt(0) + 1)) {
                            const cell = newRow.querySelector(`td[data-col="${col}"]`);
                            if (cell) {
                                rowDataObj.cells[col].content = getCellText(cell);
                                rowDataObj.cells[col].classes = Array.from(cell.classList).filter(c => 
                                    ['cell-yellow', 'cell-red', 'cell-pink', 'duplicate-cell'].includes(c)
                                );
                                rowDataObj.cells[col].comment = cell.dataset.comment || '';
                            }
                        }
                        
                        originalData.push(rowDataObj);
                    });
                    
                    updateProgress(50 + Math.min(50, (i + CONFIG.batchSize) / importTotalRows * 50));
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
                
                calculateDColumn();
                checkDuplicateCells();
                calcTargetHeader(CONFIG.calcHeaderCol);
                saveToHistory();
                hideLoading();
                showToast(`成功导入${importTotalRows}行数据！`);
            } catch (err) {
                console.error(err);
                hideLoading();
                showToast('导入失败，请检查文件格式！');
            }
            e.target.value = '';
            isProcessing = false;
        }

        // 异步读取文件
        function readFileAsync(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(e);
                reader.readAsArrayBuffer(file);
            });
        }

        // 异步解析Excel
        function parseExcelAsync(arrayBuffer) {
            return new Promise((resolve) => {
                setTimeout(() => {
                    const wb = XLSX.read(new Uint8Array(arrayBuffer), { 
                        type: 'array',
                        cellStyles: false,
                        cellNF: false,
                        cellDates: false
                    });
                    resolve(wb);
                }, 0);
            });
        }

        // 【优化版】Excel导出
        async function saveToExcel() {
            if (isProcessing) return;
            isProcessing = true;
            
            showLoading('正在生成Excel...');
            
            try {
                const headerRow = [];
                colLetters.forEach(col => {
                    headerRow.push(getCellText(getHeaderCell(col)) || col);
                });
                const rows = [headerRow];
                
                const totalRows = originalData.length;
                
                for (let i = 0; i < totalRows; i += 100) {
                    const batch = originalData.slice(i, i + 100);
                    batch.forEach((rowData) => {
                        const rowDataArr = [];
                        colLetters.forEach(col => {
                            const cellData = rowData.cells[col];
                            rowDataArr.push(cellData?.content || '');
                        });
                        rows.push(rowDataArr);
                    });
                    
                    updateProgress(Math.min(100, (i + 100) / totalRows * 100));
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
                
                const wb = XLSX.utils.book_new();
                const ws = XLSX.utils.aoa_to_sheet(rows);
                XLSX.utils.book_append_sheet(wb, ws, '药品数据');
                
                const date = new Date();
                const year = date.getFullYear();
                const month = (date.getMonth() + 1).toString().padStart(2, '0');
                const day = date.getDate().toString().padStart(2, '0');
                const hour = date.getHours().toString().padStart(2, '0');
                const minute = date.getMinutes().toString().padStart(2, '0');
                const fileName = `yb数据${year}${month}${day} ${hour}${minute}.xlsx`;

                XLSX.writeFile(wb, fileName);
                hideLoading();
                showToast(`保存成功！已导出${totalRows}行数据`);
            } catch (err) {
                console.error(err);
                hideLoading();
                showToast('保存失败！');
            }
            isProcessing = false;
        }

        function saveToLocalStorage() {
            try {
                if (!isFilterActive && document.querySelectorAll('#dataTable tbody tr').length > 0) {
                    syncOriginalDataFromDOM();
                }
                
                const compressedData = originalData.map(row => ({
                    n: row.rowNum,
                    c: Object.keys(row.cells).reduce((acc, col) => {
                        const cell = row.cells[col];
                        if (cell.content || cell.classes.length || cell.comment) {
                            acc[col] = {
                                t: cell.content,
                                s: cell.classes.join(','),
                                m: cell.comment
                            };
                        }
                        return acc;
                    }, {})
                }));
                
                const data = {
                    h: colLetters.map(col => getCellText(getHeaderCell(col))),
                    d: compressedData,
                    f: isFilterActive,
                    w: Array.from(document.querySelectorAll('#dataTable thead th:not(.row-header)')).map(th => th.style.width),
                    v: '1.1'
                };
                
                localStorage.setItem(CONFIG.storageKey, JSON.stringify(data));
                console.log('数据已保存:', new Date().toLocaleString());
                return true;
            } catch (err) {
                console.error('保存失败:', err);
                if (err.name === 'QuotaExceededError') {
                    showToast('存储空间不足，请导出数据后清理浏览器缓存！');
                }
                return false;
            }
        }

        function saveToLocalStorageDelayed() {
            if (isInitializing) return;
            if (autoSaveTimer) clearTimeout(autoSaveTimer);
            autoSaveTimer = setTimeout(() => saveToLocalStorage(), 15000);
        }

        function loadFromLocalStorage() {
            try {
                const savedData = localStorage.getItem(CONFIG.storageKey);
                if (!savedData) return false;
                
                const data = JSON.parse(savedData);
                if (!data.d || data.d.length === 0) return false;
                
                console.log('加载数据，版本:', data.v);
                
                originalData = data.d.map(row => ({
                    rowNum: row.n,
                    cells: Object.keys(row.c).reduce((acc, col) => {
                        const cell = row.c[col];
                        acc[col] = {
                            content: cell.t || '',
                            classes: cell.s ? cell.s.split(',') : [],
                            comment: cell.m || '',
                            width: ''
                        };
                        return acc;
                    }, {})
                }));
                
                const tbody = document.getElementById('tableTbody');
                tbody.innerHTML = '';
                
                if (data.h) {
                    colLetters.forEach((col, idx) => {
                        const th = getHeaderCell(col);
                        if (th && data.h[idx]) {
                            setCellText(th, data.h[idx]);
                            th.querySelector('input').value = data.h[idx];
                        }
                    });
                }
                
                if (data.w) {
                    colLetters.forEach((col, idx) => {
                        const th = getHeaderCell(col);
                        if (th && data.w[idx]) {
                            th.style.width = data.w[idx];
                            th.style.minWidth = data.w[idx];
                        }
                    });
                }
                
                renderAllRowsFromOriginalData();
                
                isFilterActive = data.f || false;
                document.getElementById('filterToggle').classList.toggle('active', isFilterActive);
                
                if (isFilterActive) applyFilter();
                
                return true;
            } catch (err) {
                console.error('加载失败:', err);
                return false;
            }
        }

        function saveToHistory() {
            if (isUndoRedo) return;
            redoStack = [];
            
            if (!isFilterActive) syncOriginalDataFromDOM();
            
            if (historyStack.length >= CONFIG.maxHistory) {
                historyStack.shift();
            }
            
            const snapshot = {
                h: colLetters.map(col => getCellText(getHeaderCell(col))),
                d: JSON.parse(JSON.stringify(originalData)),
                f: isFilterActive,
                w: Array.from(document.querySelectorAll('#dataTable thead th:not(.row-header)')).map(th => th.style.width)
            };
            
            historyStack.push(snapshot);
            updateUndoRedoButtons();
        }

        function undo() {
            if (historyStack.length <= 1) return;
            isUndoRedo = true;
            redoStack.push(historyStack.pop());
            restoreTableState(historyStack[historyStack.length-1]);
            isUndoRedo = false;
            updateUndoRedoButtons();
        }

        function redo() {
            if (redoStack.length === 0) return;
            isUndoRedo = true;
            historyStack.push(redoStack.pop());
            restoreTableState(historyStack[historyStack.length-1]);
            isUndoRedo = false;
            updateUndoRedoButtons();
        }

        function restoreTableState(state) {
            clearRowColHighlight();
            
            colLetters.forEach((col, idx) => {
                const th = getHeaderCell(col);
                if (state.w[idx]) {
                    th.style.width = state.w[idx];
                    th.style.minWidth = state.w[idx];
                }
                setCellText(th, state.h[idx]);
                th.querySelector('input').value = state.h[idx];
            });
            
            originalData = JSON.parse(JSON.stringify(state.d));
            
            const tbody = document.getElementById('tableTbody');
            tbody.innerHTML = '';
            
            if (state.f) {
                applyFilter();
            } else {
                renderAllRowsFromOriginalData();
            }
            
            isFilterActive = state.f;
            document.getElementById('filterToggle').classList.toggle('active', isFilterActive);
            
            calculateDColumn();
            checkDuplicateCells();
            updateUndoRedoButtons();
        }

        function updateUndoRedoButtons() {
            document.getElementById('undoBtn').classList.toggle('btn-disabled', historyStack.length <= 1);
            document.getElementById('redoBtn').classList.toggle('btn-disabled', redoStack.length === 0);
        }
    </script>
</body>
</html>
